
\newcommand{\push}{\mbox{\sc Push}}
\newcommand{\trypush}{\mbox{\sc TryPush}}
\newcommand{\recoverPush}{\mbox{\sc Push-Roceover}}
\newcommand{\pop}{\mbox{\sc Pop}}
\newcommand{\trypop}{\mbox{\sc TryPop}}
\newcommand{\recoverPop}{\mbox{\sc Pop-Recover}}
\newcommand{\recover}{\mbox{\sc Recover}}
\newcommand{\exchange}{\mbox{\sc Exchange}}
\newcommand{\recoverExchange}{\mbox{\sc Exchange-Recover}}
\newcommand{\visit}{\mbox{\sc Visit}}
\newcommand{\switchPair}{\mbox{\sc SwitchPair}}
\newcommand{\search}{\mbox{\sc Search}}


\newcommand{\init}{\mbox{$\bot$}}
\newcommand{\NULL}{\mbox{\sc Null}}
\newcommand{\fail}{\mbox{\sc Fail}}
\newcommand{\emptyst}{\mbox{\sc Empty}}
\newcommand{\waiting}{\mbox{\sc Waiting}}
\newcommand{\busy}{\mbox{\sc Busy}}
\newcommand{\timeout}{\mbox{\sc Timeout}}

\newcommand{\Info}{\mbox{Info}}
\newcommand{\opInfo}{\mbox{OpInfo}}
\newcommand{\pushInfo}{\mbox{PushInfo}}
\newcommand{\popInfo}{\mbox{PopInfo}}
\newcommand{\exInfo}{\mbox{ExInfo}}


\newcommand{\comnospace}{\mbox{$\triangleright$}}
\newcommand{\com}{\mbox{\comnospace\ }}
\newcommand{\tabtabcom}{\>\>\com}
\newcommand{\tabcom}{\>\com}


\section{Elimination Stack}

For simplicity, we assume a value \init, which is different from \NULL\ and any other value the stack can store. Since \NULL\ is used as a legit return value, representing the value of \pop\ operation (when exchanging values using the elimination array), \NULL\ can not be used to represent an initialization value, different then any stack value. The same holds for a Node, since a \NULL\ node represent an empty stack, the value \init\ is used to distinguish between initialization value and empty stack.

For simplicity, we split the \recover\ routine into sub-routines, based on which operation (\push, \pop, \exchange) is pending, or needs to be recover. This can be concluded easily by the type of record stored in $Announce[pid]$ (\exInfo\ or \opInfo), thus there is no need to explicitly know where exactly in the code the crash took place. Also, the \recover\ routine returns \fail\ in case the last pending operation did not took affect (no linearization point), nor it will take in any future run. In such case, the user has the option to either re-invoke the operation, or to skip it, depends on the needs and circumstances of the specific use of the data structure.

The given implementation ignores the log of failures and successes of the exchange routine when recovering. That is, in case of a crash during an \exchange, a process is able to recover the \exchange\ routine, however, the log of successes and failures is not update, since it might be the process already updated it. In addition, in case of a \fail\ response, we do not know whether the time limit (timeout) was reached, or that the process simply crashed earlier in the routine without completing it. The given implementation can be expanded to also consider the log. Nonetheless, for ease of presentation we do not handle the log in case of a crash. Assuming crash events are rare, the log still gives a roughly good approximation to the number of failures and successes, thus our approach might be useful in practice.

\subsection{A Lock-Free Exchanger}
An exchanger object supports the \exchange\ procedure, which allows exactly two processes to exchange values. 
If process A calls the \exchange\ with argument $a$, and B calls the \exchange\ of the same object with argument $b$, then A's call will return value $b$ and vice versa.

On the original algorithm [cite the book?!], processes race to win the exchanger using a \CAS\ primitive. A process accessing the exchanger first reads its content, and act according to the state of it. The first process observe an \emptyst\ state, and tries to atomically writes its value and change the state to \waiting. In such case, it spins and wait for the second process to arrive. The second, observing the state is now \waiting, tries to write its value and change the state to \busy. This way, it informs the first one a successful collision took place. Once the first process notice the collision, it reads the other process value and release the exchanger by setting it back to \emptyst.
In order to avoid an unbounded waiting, if a second process does not show up, the call eventually timeout, and the process release the exchanger and return.

Assume a process $p$ successfuly capture the exchanger by setting its status to \waiting, followed by a crash. Now, some other process $q$ complete the exchange by setting the exchanger to \busy. Upon recovery, $p$ can conclude some exchange was completed, but it can not tell whether its value is part of the exchange, and thus it can not complete the operation. Moreover, $p$ and $q$ must agree, otherwise $q$ will return $p$'s value, and thus the operation of $p$ must be linearized together with $q$ operation.

In order to avoid the above problem, we take an approach resembling the BST implementation. Instead of writing a value to the exchanger, processes will use an info record, containing the relevant information for the exchange. This way, processes use the exchanger in order to exchange info records (more precisely, pointers to such records), and not values. To overcome the problematic scenario described earlier, if a process $q$ observe the exchanger state is \waiting\ with some record $yourop$, it first update its own record $myop$ it is about to try and collide with $yourop$, and only then performs the \CAS. This way, if the collision is successful, the record $myop$ which now stored in the exchanger implies which two records collide. Also, the fact that different processes uses different records guarantee that at most one record can collide with $yourop$.

Using records instead of values results some more positive implications. First, there is no need to store the exchanger's state in it (by using 2 bits of it to mark the state), but we can rather have this info in the record. Second, if there is a \busy\ record in the exchanger, it contains the info of the two colliding records. Therefore, a third process, trying to also use the exchanger, can help the processes to complete the collision, and then can try and set the exchanger back to \emptyst, so it can use it again. In the original implementation, a process observaing a \busy\ exchanger, have to wait for the first process to read the value and release the exchanger. Therefore, if the first process crash after the collision, the exchanger will be hold by it forever. The helping mechanism avoids this scenario, making the exchange routine non-blocking.

Notice that no exchange record with \emptyst\ state is ever created, except for the $default$ record. Therefore, reading \emptyst\ state is equivalent to the exchanger storing a pointer to $default$. Every process creates new record when accessing the exchanger, with a unique address. As long as a process fails to perform a successful \CAS, and thus fails to store its pointer in $slot$, it is allowed to try again. However, once a process performs a successful \CAS\ and stores $myop$ in $slot$, the only other \CAS\ it is allowed to do are in order to try and store $defualt$ in $slot$. Thus, if no crash occurs, $myop$ can be written exactly once to $slot$. It follows that a collision can occur between two processes exactly - once a \waiting\ record stored in $slot$, only a single \CAS\ can replace it with a \busy\ record. As the two records can not be written again to $slot$, no other process can collide with any of the records.

Assume process $p$ crash along the \exchange\ routine. Upon recovery, in the \recoverExchange\, it first read $myop = Announce[pid]$. There are two scenarios to consider.
If process $p$ crash while $myop.state = \busy$, then $p$ crashed while or after an attempt to collide with $myop.partner$. Notice that there was a point in time where $partner$ was stored in $slot$ with state \waiting, as these are the only values that can be written to $myop.partner$. if $p$ did not succeed to collide with $partner$, then $myop$ is never written to $slot$. In particular, no other process can read $myop$, or write to any of its fields. Thus, the if in lines \ref{exchange-rec-busy-if} and \ref{exchange-rec-result-if} do not hold, and $p$ will return \fail.
Otherwise, $p$ performed a successful \CAS, replacing $partner$ with $myop$. The only way to write a new value to $slot$ is by a \CAS\ with $myop$ as a parameter. This in turns, happens only after a process reads $myop$, and since its status is \busy, a \switchPair\ routine is invoked with $myop$ and $partner$. Thus, either $p$ will read $myop$ from $slot$, or that $myop$ was replaced, but a \switchPair\ routine completed the collision, and $myop.result$ is updated. In both cases, $p$ will return $myop.result$ as required.

Otherwise, $p$ crash while $myop.state = \waiting$. Thus, $p$ may be after trying to perform a \CAS\ to replace $defalut$ with $myop$.


\begin{figure*}[b]
	\small
	
	Type Node \{ \\
		\hspace*{6mm} T $value$ \\
		\hspace*{6mm} int $popby$ \\
		\hspace*{6mm} Node $*next$ \\
	\} \\
	
	
	Type \pushInfo\ \{ \hspace*{20.0mm} $\triangleright$ subtype of \Info \\
		\hspace*{6mm} Node $*pushnd$ \\
	\} \\
	
	Type \popInfo\ \{ \hspace*{22.0mm} $\triangleright$ subtype of \Info \\
		\hspace*{6mm} Node $*popnd$ \\
	\} \\
	
	
	Type \exInfo\ \{ \hspace*{24.0mm} $\triangleright$ subtype of \Info \\
	\hspace*{6mm} \{\emptyst, \waiting, \busy\} $state$ \\
	\hspace*{6mm} T $value, result$ \\
	\hspace*{6mm} \exInfo\ $*partner, *slot$ \\
	\}
	
	\caption{Type definition}
\end{figure*}



%%%%%%%%%%%%%%%%%%Elimination array%%%%%%%%%%%%%%%%%
\begin{figure*}
	\small
	
	\exInfo\ $default$ - global static \exInfo\ object with state = \emptyst
	
\begin{algorithm}[H]
	\caption{T \exchange\ (\exInfo\ $*slot$, T $myitem$, long $timeout$)}
	
	long $timeBound$ := getNanos() + $timeout$ \;
	\exInfo\ $myop$ := new \exInfo (\waiting, $myitem$, \init, \init, $slot$)\;
	$Announce[pid]$ := $myop$ \;
	
	\While{\True} {
		\uIf{getNanos() $> timeBound$} {
			$myop.result := \timeout$ \tcp*{time limit reached}
			\KwRet \timeout 
		}
		%$myop.state$ := \waiting \tcp*{set to default state}
		$yourop := slot$ \;
%		$\langle$youritem,state$\rangle$ := slot\;
		\Switch{$yourop.state$} {
			\uCase{\emptyst} {
				$myop.state$ := \waiting \tcp*{attempt to replace $default$}
				$myop.partner := \init$ \;
				\If (\tcp*[f]{try to collide}) {$slot.\CAS (yourop, myop)$} {
					\While{getNanos() $< timeBound$}{
						$yourop := slot$ \;
						\uIf(\tcp*[f]{a collision was done}) {$yourop \neq myop$} {
							\uIf (\tcp*[f]{$yourop$ collide with $myop$}) {$youop.parnter = myop$} {
								\switchPair $(myop, yourop)$ \;
								$slot.\CAS (yourop, default)$ \tcp*{release $slot$}
							}
							\KwRet $myop.result$ \;
						}
					}
					\tcp{time limit reached and no process collide with me}
					\uIf (\tcp*[f]{try to release $slot$}) {$slot.\CAS(myop, default)$}{
						$myop.result := \timeout$ \;
						\KwRet \timeout\;
					} \uElse (\tcp*[f]{some process show up}) {
						$yourop := slot$ \;
						\uIf{$yourop.partner = myop$} {
							\switchPair $(myop, yourop)$ \tcp*{complete the collision}
							$slot.\CAS (yourop, default)$ \tcp*{release $slot$}
						}
						\KwRet $myop.result$ \;
					}
				}
				break \;
			}
			\uCase (\tcp*[f]{some process is waiting in $slot$}){\waiting} {
				$myop.partner := yourop$ \tcp*{attempt to replace $yourop$}
				$myop.state := \busy$ \;
				\uIf (\tcp*[f]{try to collide}){$slot.\CAS (yourop, myop)$} {
					\switchPair $(myop, yourop)$ \tcp*{complete the collision}
					$slot.\CAS (myop, default)$ \tcp*{release $slot$}
					\KwRet $myop.result$ \;
				}
				break \;
			}
			\uCase (\tcp*[f]{a collision in progress}) {\busy} {
				\switchPair $(yourop, yourop.parnter)$ \tcp*{help to complete the collision}
				$slot.\CAS (yourop, default)$ \tcp*{release $slot$}
				break \;
			}
		}	
	} 
\end{algorithm}

\end{figure*}




\begin{figure*}
	\small
	
\begin{algorithm}[H]
	\caption{void \switchPair (\exInfo\ $first$, \exInfo\ $second$)}
	
	\tcc{exchange the valus of the two operations}
	$first.result := second.value$ \;
	$second.result := first.value$ \;
	
\end{algorithm}

\begin{algorithm}[H]
	\caption{T \visit\ (T $value$, int $range$, long $duration$)}
	
	\tcc{invoke \exchange\ on a random entery in the collision array}
	int $cell$ := randomNumber$(range)$ \;
	\KwRet \exchange$(exchanger[cell], value, duration)$
\end{algorithm}

\begin{algorithm}[H]
	\caption{T \recoverExchange\ $()$}
	
	\exInfo\ $*myop := Announce[pid]$ \tcp*{read your last operation record}
	\exInfo\ $*slot := myop.slot$ \tcp*{and the slot on which it acts}
	
	\uIf {$myop.state = \waiting$} {
		\tcc{crash while trying to exchange $defualt$, or waiting for a collision}
		$yourop := slot$ \;
		\uIf (\tcp*[f]{still waiting for a collision}) {$yourop = myop$} {
			\uIf (\tcp*[f]{try to release $slot$}){$slot.\CAS(myop, default)$}{\KwRet \fail}
			\uElse (\tcp*[f]{some process show up}) {
				$yourop := slot$ \;
				\uIf{$yourop.partner = myop$} {
					\switchPair$(myop, yourop)$ \tcp*{complete the collision}
					$slot.\CAS (yourop, default)$ \tcp*{release $slot$}
				}
				\KwRet $myop.result$ \;
				%\textbf{go to} \ref{ExRecover-successful} \;
			}	
		}
		\uElseIf (\tcp*[f]{$yourop$ collide with $myop$}) {$yourop.partner = myop$} {
			\switchPair$(myop, yourop)$ \tcp*{complete the collision}
			$slot.\CAS (yourop, default)$ \tcp*{release $slot$}
			\KwRet $myop.result$ \;
		}
		%\uIf {$myop.result \neq \init$} {\KwRet $myop.result$ \;}
		%\KwRet \fail	
	}
	\uIf {$myop.state = \busy$} {
		\tcc{crash while trying to collide with $myop.partner$}
		$yourop := slot$ \;
		\uIf (\tcp*[f]{collide was successful and in progress}) {$yourop = myop$ \label{exchange-rec-busy-if}} {
			\switchPair$(myop, myop.partner)$ \tcp*{complete the collision}
			$slot.\CAS (myop, default)$ \tcp*{release $slot$}
			\KwRet $myop.result$ \;
			%\textbf{go to} \ref{ExRecover-successful} \;
		}	
	}
	\uIf {$myop.result \neq \init$ \label{exchange-rec-result-if}} {
		\KwRet $myop.result$ \tcp*{collide was successfuly completed}
	}
	\uElse {\KwRet \fail}

	\remove{
	returnCode: \tcp*{successful exchange} \label{ExRecover-successful}
	\uIf {exactly one of \{myop.value, myop.result\} is \NULL}
		{KwRet myop.result \tcp*[f]{Exchange of \push and \pop}}
	\uElse {\KwRet \fail \tcp*[f]{Exchange of two operations of the same type}}
	}
\end{algorithm}

\caption{Elimination Array routines}
\end{figure*}



%%%%%%%%%%%%%%%%%%PUSH%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}
	
\begin{algorithm}[H]
	\caption{boolean \trypush\ (Node $*nd$)}
	
	\tcc{attempt to perform \push\ to the central stack}
	Node $*oldtop := Top$\;
	$nd.next := oldtop$\;
	\uIf (\tcp*[f]{try to declare $nd$ as the new $Head$}) {$Top.\CAS(oldtop, nd)$} {
		$nd.popby.\CAS(\init, \NULL)$ \tcp*{announce $nd$ is in the stack}
		\KwRet \True
	} 
	\KwRet \False
\end{algorithm}

\begin{algorithm}[H]
	\caption{boolean \push\ (T $myitem$)}
	
	Node $*nd$ = new Node $(myitem)$ \;
	$nd.popby := \init$ \;
	
	\pushInfo\ $data$ := new \pushInfo\ ($nd$) \;
	\While{\True}{
		$Announce[pid] := data$ \tcp*{declare - trying to push node $nd$}
		\uIf (\tcp*[f]{if central stack \push\ is successful}){\trypush$(nd)$} {\KwRet \True}
		$range$ := CalculateRange() \tcp*{get parameters for collision array}
		$duration$ := CalculateDuration()\;
		$othervalue$ := \visit$(myitem, range, duration)$ \tcp*{try to collide}
		\uIf (\tcp*[f]{successfuly collide with \pop\ operation}) {$othervalue = \NULL$}{
			RecordSuccess ()\;
			\KwRet \True\;
		} \uElseIf (\tcp*[f]{failed to collide}) {$othervalue = \timeout$} {RecordFailure ()}
	}
\end{algorithm}


\begin{algorithm}[H]
	\caption{boolean \recoverPush\ $()$}
	
	Node $*nd := Announce[pid].pushnd$ \;
	\uIf (\tcp*[f]{$nd$ was announced to be in the stack}) {$nd.popby \neq \init$} {\KwRet \True}
	\uIf (\tcp*[f]{$nd$ in the stack, or was announced as such}) {$\search(nd) \mid \mid  nd.popby \neq \init$} {
		$nd.popby.\CAS(\init, \NULL)$ \tcp*{announce $nd$ is in the stack}
		\KwRet \True \;
	}
	\KwRet \fail \;
\end{algorithm}

\begin{algorithm}[H]
	\caption{boolean \search\ (Node $*nd$)}
	
	\tcc{search for node $nd$ in the stack}
	
	Node $*iter := Top$ \;
	\While{$iter \neq \init$}{
		\uIf {$iter = nd$} {\KwRet \True}
		$iter := iter.next$	
	}
	\KwRet \False
\end{algorithm}

\caption{\push\ routine}
\end{figure*}




%%%%%%%%%%%%%%%%%%POP%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}

\begin{algorithm}[H]
	\caption{T \trypop $()$}
	
	Node $*oldtop := Top$ \;
	Node $*newtop$ \;
	$Announce[pid].popnd := oldnop$ \tcp*{declare - trying to pop node $oldtop$}
	\uIf (\tcp*[f]{stack is empty}) {$oldtop = \init$} {\KwRet \emptyst}
	$newtop := oldtop.next$ \;
	$oldtop.popby.\CAS(\init,\NULL)$ \tcp*{announce $oldtop$ is in the stack}
	\uIf (\tcp*[f]{try to pop $oldtop$ by changing $Top$ to $newtop$}) {$Top.\CAS(oldtop, newtop)$}{
		\uIf (\tcp*[f]{try to announce yourself as winner}) {$newtop.popby.\CAS(\NULL, pid)$} {\KwRet $oldtop.value$}
	}
	\uElse {\KwRet \init}
\end{algorithm}

\begin{algorithm}[H]
	\caption{T \pop\ $()$}
	
	Node $*result$ \;
	\popInfo\ $data$ := new \popInfo\ ($Top$) \;
	
	\While{\True}{
		$Announce[pid] := data$ \tcp*{declare - trying to perform \pop}
		$result$ := \trypop $()$ \tcp*{attempt to pop from central stack}
		%\uIf {$result = \emptyst$} {\KwRet \emptyst}
		\uIf (\tcp*[f]{if central stach \pop\ is successful}) {$result \neq \init$} {\KwRet $result$}
		$range$ := CalculateRange() \tcp*{get parameters for collision array}
		$duration$ := CalculateDuration()\;
		$othervalue$ := \visit $(\NULL, range, duration)$ \tcp*{try to collide}
		\uIf (\tcp*[f]{failed to collide}) {$othervalue = \timeout$}{RecordFailure ()}
		\uElseIf (\tcp*[f]{successfuly collide with \push\ operation}) {$othervalue \neq \NULL$} {
			RecordSuccess ()\;
			\KwRet $othervalue$
		}
	}
	
\end{algorithm}

\begin{algorithm}[H]
	\caption{T \recoverPop $()$}
	
	Node $*nd := Announce[pid].popnd$ \tcp*{crash while trying to pop node $nd$}
	\uIf (\tcp*[f]{pop from an empty stack}) {$nd = \init$} {\KwRet \emptyst}
	%\uIf {$nd.popby = pid$} {\KwRet $nd.value$}
	\uIf (\tcp*[f]{$nd$ was not removed from the stack}) {$\search(nd)$} {\KwRet \fail}
	$nd.popby.\CAS(\NULL, pid)$ \tcp*{$nd$ was removed. Try to complete the operation}
	\uIf (\tcp*[f]{you are the process to win the pop of $nd$}) {$nd.popby = pid$} {\KwRet $nd.value$}
	\KwRet \fail
\end{algorithm}

\caption{\pop\ routine}
\end{figure*}


 