\documentclass[8pt]{article}
\usepackage[dvips]{color}
\usepackage{epsfig}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{smartref} % for referencing the line numbers


%% increase page size
\setlength{\evensidemargin}{-.1in}
\setlength{\oddsidemargin}{-.1in}
%\setlength{\marginparwidth}{0in}
\setlength{\textwidth}{6.7in}
\setlength{\textheight}{9.2in}
\setlength{\topmargin}{-.1in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
%\setlength{\itemsep}{-\parsep}
%\setlength{\labelsep}{0.25cm}
\renewcommand{\baselinestretch}{0.965}

\newcommand{\capspace}{\vspace*{-5mm}}

% PODC submission rules:  12 pages + 1 page for references + appendix

% Environment for entering source code======================================
% Example:
% 
% 1  function p
% 2      for i:1..10
% 3           i *= 2
% 4           i -= 1
% 5      end for
%    end p
% 
% this can be typed as follows:
%
% \begin{code}
% \firstline          <--- to number the first line of a code environment
% function p \nl      <--- \nl ends line and makes next line a Numbered Line
% \n for i:1..10 \nl  <--- \n increases the level of indentation ("next")
%    \n i*=2 \nl
%       i-=1 \nl
%    \p end for \ul   <--- \ul ends line and makes next line an Unnumbered Line 
% \p end p            <--- \p decreases the level of indentation ("previous")
% \end{code}
% 
% You can use \labels anywhere in the code and \lref to refer to the line
% number.  (This is done using smartref package.)
% 
\newcounter{linenum}
\addtoreflist{linenum}
\def\codeTabSpace{\hspace*{6mm}}
\newenvironment{code}%
{\begin{tabbing}%
		\codeTabSpace \= \hspace*{70mm} \= \hspace*{42mm} \= \kill%
	}%
	{\end{tabbing}%
}
\newcounter{ind}
\newcommand{\n}{\addtocounter{ind}{7}\hspace*{7mm}}
\newcommand{\p}{\addtocounter{ind}{-7}\hspace*{-7mm}}
\newcommand{\nl}{\\\stepcounter{linenum}{\scriptsize \arabic{linenum}}\>\hspace*{\value{ind}mm}}
\newcommand{\ul}{\\\>\hspace*{\value{ind}mm}}
\newcommand{\bl}{\\[-1.5mm]\>\hspace*{\value{ind}mm}}
\newcommand{\firstline}{\stepcounter{linenum}{\scriptsize \arabic{linenum}}\>}
\newcommand{\lref}[1]{\linenumref{#1}} % use this to refer to a line number
% End of stuff for entering source code=====================================

\newcommand{\postnotnull}{(1)}
\newcommand{\postl}{(2)}
\newcommand{\postpup}{(3)}
\newcommand{\postnonempty}{(4)}
\newcommand{\postgpnotnull}{(4a)}
\newcommand{\postp}{(4b)}
\newcommand{\postgpup}{(4c)}

\newcommand{\tabtabcom}{\>\>\com}
\newcommand{\tabcom}{\>\com}



\newcommand{\Key}{Key}
\newcommand{\R}{{\bf R}}
\newcommand{\NULL}{\mbox{$\bot$}}
\newcommand{\clean}{\mbox{\sc Clean}}
\newcommand{\mk}{\mbox{\sc Mark}}
\newcommand{\insertflag}{\mbox{\sc InsertFlag}}
\newcommand{\deleteflag}{\mbox{\sc DeleteFlag}}
\newcommand{\record}{\mbox{record}}
\newcommand{\info}{\mbox{info}}

\newcommand{\Flag}{Flag}
\newcommand{\DFlag}{D\Flag}
\newcommand{\IFlag}{I\Flag}

\newcommand{\ie}{{\it i.e.}}
\newcommand{\TRUE}{\mbox{\sc True}}
\newcommand{\FALSE}{\mbox{\sc False}}

\newcommand{\func}[1]{\mbox{\sc #1}}

\newcommand{\CAS}{\func{CAS}}

\newcommand{\comnospace}{\mbox{$\triangleright$}}
\newcommand{\com}{\mbox{\comnospace\ }}

\newcommand{\doublespace}{\addtolength{\baselineskip}{.8\baselineskip}}
\newcommand{\ds}{\addtolength{\baselineskip}{.9\baselineskip}}

%%%%%%%%%%%%%%%%%%%%% COMMENTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%% New state-of-the-art method for comment insertion
%%%% by multiple distributed authors.
%%%% These comments are present in the LATEX file and
%%%% do not appear in print.
%
%% define debug: use first def for debug, second def for final version
\newcommand{\debug}[1]{#1}
%\newcommand{\debug}[1]{}
%

%% \newcommand{\comment}[1]{\debug{\marginpar {\sloppy\tiny #1}}}
\newcommand{\lcomment}[1]{\debug{\comment{$\rightarrow$ #1}}}
\newcommand{\incomment}[1]{\debug{[[[#1]]]}}
%
\newcommand{\fM}[1]{\comment{#1 5-14 M.}}
\newcommand{\fD}[1]{\comment{#1 5-21 D.}}
\newcommand{\upcom}[1]{#1}
%
%%%%%%%%%%%%%%%% end of comments %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%

%
%
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{example}[theorem]{Example}
\newtheorem{assumption}[theorem]{Assumption}
\newtheorem{invariant}[theorem]{Invariant}
%
%
\newtheorem{conjecture}{Conjecture}[section]

%
%
% to get nice proofs ...
\newcommand{\qedsymb}{\hfill{\rule{2mm}{2mm}}}
\newenvironment{proof}{\begin{trivlist}
		\item[\hspace{\labelsep}{\bf\noindent Proof: }]
	}{\qedsymb\end{trivlist}}
\newenvironment{prf}{{\bf\noindent Proof: }}{\qedsymb}
%
%
\newenvironment{sketchofproof}{\begin{trivlist}
		\item[\hspace{\labelsep}{\bf\noindent Sketch of Proof: }]
	}{\qedsymb\end{trivlist}}
\newenvironment{sprf}{{\bf\noindent Sketch of Proof: }}{\qedsymb}
%
\newenvironment{prfsketch}{\begin{trivlist}
		\item[\hspace{\labelsep}{\bf\noindent Sketch of proof: }]
	}{\qedsymb\end{trivlist}}
%
%
%
%\newcommand{\qed}{\hfill\rule{2mm}{2mm}}
%
%
%
\newenvironment{remark}{\begin{trivlist}
		\item[\hspace{\labelsep}{\bf\noindent Remark. }]}{\end{trivlist}}
%
%
%
% this command enables to remove a whole part of the text
% from the printout
% to use it just enter
% \remove{
% before the text to be excluded and
% }
% after the text
\newcommand{\remove}[1]{}
%
%

\newenvironment{centre}{\begin{center}}{\end{center}}
% sets up centre as alternate name for center.


\def\draft{\sc (Draft of \MonthDayYear\ at \HourMinutes)}
%
%



% marginal comment
\newcommand{\comment}[1]{\marginpar{\tiny #1}}
%\mnote{Example: only one algorithm is typed in so far.}
\newcommand{\mnote}[1]
{\marginpar%
	[{\tiny\begin{minipage}[t]{\marginparwidth}\raggedright#1%
	\end{minipage}}]%
	{\tiny\begin{minipage}[t]{\marginparwidth}\raggedright#1%
	\end{minipage}}%
}



%\newcommand{\here}[1]{[[[#1]]]\marginpar{***}}
\newcommand{\ignore}[1]{}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}

\newcommand{\lft}{\mbox{\it left}}

\thispagestyle{empty}


%
%%%%%%%%%%%%%%%% document %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%


\begin{document}
	
	
\begin{figure}[bt]
	\begin{code}
		\firstline
		type Update \{ \hspace*{14mm} \com stored in one CAS word\nl
		\n  $\{\clean,\deleteflag,\insertflag,\mk\}$ $state$ \nl
		\Flag\ *{\it info}\nl
		\p
		\}
		\nl
		type Internal \{ \hspace*{13.25mm} \com subtype of Node\nl
		\n $\Key \cup \{\infty_1,\infty_2\}$ $key$\nl
		Update $update$\nl
		Node *\lft, *$right$\nl
		\p\}
		\nl
		type Leaf \{ \hspace*{18.3mm} \com subtype of Node\nl
		%\hspace*{4mm} \com could also store auxiliary information\nl 
		\n $\Key \cup \{\infty_1,\infty_2\}$  $key$\nl
		\p\}
		\nl
		type \IFlag\ \{ \hspace*{17.7mm} \com subtype of \Flag\nl
		\n Internal *$p$, *$newInternal$\nl
		Leaf *$l$\nl
		\p\}
		\nl
		type \DFlag\ \{ \hspace*{16.4mm} \com subtype of \Flag\nl
		\n Internal *$gp$, *$p$\nl
		Leaf *$l$\nl
		Update $pupdate$\nl
		\p\}   
		\ul
		\com Initialization:\nl
		shared Internal *$Root$ := pointer to new Internal node \ul
		\n with $key$ field $\infty_2$, $update$ field $\langle \clean,\NULL\rangle$, and\ul
		pointers to new Leaf nodes with keys $\infty_1$ and\ul 
		$\infty_2$, respectively, as \lft\ and $right$ fields.
		\p 
	\end{code}
	\caption{\label{code1}Type definitions and initialization.}
\end{figure}


\begin{figure*}
	\begin{code}
		\firstline
		\func{Search}($\Key\ k$) : $\langle \mbox{Internal*}, \mbox{Internal*}, \mbox{Leaf*}, \mbox{Update}, \mbox{Update}\rangle$  \{\ul
		\n \com Used by \func{Insert}, \func{Delete} and \func{Find} to traverse a branch of the BST; satisfies following {\it postconditions}:\ul
		\com \postnotnull\ $l$ points to a Leaf node and $p$ points to an Internal node\ul
		\com \postl\ Either $p\rightarrow \lft$ has contained $l$ (if $k<p\rightarrow key$) or $p\rightarrow right$ has contained $l$ (if $k\geq p\rightarrow key$)\ul
		\com \postpup\ $p\rightarrow update$ has contained $pupdate$\ul
		\com \postnonempty\ if $l\rightarrow key\neq \infty_1$, then the following three statements hold:\ul
		\com \hspace*{3mm}\postgpnotnull\ $gp$ points to an Internal node\ul
		\com \hspace*{3mm}\postp\ either $gp\rightarrow \lft$ has contained $p$ (if $k<gp\rightarrow key$) or $gp\rightarrow right$ has contained $p$ (if $k\geq gp\rightarrow key$)\ul
		\com \hspace*{3mm}\postgpup\ $gp\rightarrow update$ has contained $gpupdate$\nl
		Internal *$gp$, *$p$\nl
		Node *$l:= Root$  \label{restart-search}\nl
		
		Update $gpupdate, pupdate$ \tabtabcom Each stores a copy of an $update$ field\bl\nl
		%\com The initial values of $p,gp,pupdate$ and $gpupdate$ are unimportant
		%$p :=\NULL$ 
		%$pupdate := \langle \clean, \NULL\rangle$\nl
		while $l$ points to an internal node \{ \nl%\com Advance down the tree\nl
		\n         $gp := p$ \tabtabcom Remember parent of $p$\nl
		$p := l$ \tabtabcom Remember parent of $l$\nl
		$gpupdate := pupdate$ \tabtabcom Remember $update$ field of $gp$\nl
		$pupdate := p\rightarrow update$\label{store-pupdate}\tabtabcom Remember $update$ field of $p$\nl  
		%           if $pupdate.state = \mk$ then \label{checkmark} \{\nl
		%\n              \func{HelpMarked}$(pupdate.info)$ \label{call-hm3}\nl
		%                goto line \lref{restart-search} \com Restart traversal\nl
		%\p         \}\nl        
		if $k < l\rightarrow key$ then $l:= p\rightarrow \lft$ else $l:=p \rightarrow right$ \label{read-child}\tabtabcom Move down to appropriate child\nl
		%           if $pupdate \neq p\rightarrow update$ then goto line \lref{restart-search} \com Restart traversal \label{reread-pupdate}\nl
		\p \} \nl
		return $\langle gp, p, l, pupdate, gpupdate \rangle$ \nl
		\p 
		\}\bl
		\nl
		\func{Find}($\Key\ k$) : Leaf* \{ \nl
		\n   Leaf *$l$\bl
		\nl
		%     Update $pupdate,gpupdate$\ul \nl
		$\langle -,-,l,-,-\rangle := \func{Search}(k)$\nl
		if $l\rightarrow key = k$ then return $l$\nl
		else return \NULL\nl
		\p
		\}\bl
		\nl
		\func{Insert}($\Key\ k$) : boolean \{ \nl
		\n Internal *$p$, *$newInternal$\nl 
		Leaf *$l$, *$newSibling$\nl 
		Leaf *$new :=$ pointer to a new Leaf node whose $key$ field is $k$  \nl
		Update $pupdate, result$\nl
		\IFlag\ *$op$\bl\nl%:=$ pointer to a new \IFlag\ \record\ \ul\nl
		while \TRUE\ \{  \nl
		\n $\langle -, p, l, pupdate, - \rangle := \func{Search}(k)$ \label{ins-search}\nl
		if $l \rightarrow key = k$ then return \FALSE\ \tabtabcom Cannot insert duplicate key\label{insert-false}\nl
		if $pupdate.state \neq \clean$ then \func{Help}$(pupdate)$ \tabtabcom Help the other operation \label{ins-help-unclean}\nl
		else \{\nl
		\n        $newSibling :=$ pointer to a new Leaf whose key is $l\rightarrow key$\nl
		$newInternal :=$ pointer to a new Internal node with $key$ field $\max(k, l \rightarrow key)$,\label{create-internal}\ul      
		\n      $update$ field $\langle \clean, \NULL\rangle$, and with two
		child fields equal to $new$ and $newSibling$\ul 
		(the one with the smaller key is the left child)\nl
		\p        $op :=$ pointer to a new \IFlag\ \record\  containing $\langle p, l, newInternal\rangle$\label{new-IFlag}\nl
		$result := \CAS(p\rightarrow update, pupdate, \langle \insertflag, op\rangle)$ \tabtabcom {\bf iflag \CAS}\label{iflag-cas} \nl
		if $result = pupdate$ then \{ \tabtabcom The iflag \CAS\ was successful\nl
		\n            \func{HelpInsert}$(op)$ \tabtabcom Finish the insertion\label{finish-insert}\nl
		return \TRUE\ \label{insert-true}\nl
		\p        \}\nl 
		else \func{Help}$(result)$ \tabcom The iflag \CAS\ failed; help the operation that caused failure\label{ins-help-after-failure}\nl
		\p    \}\nl
		\p\}\nl 
		\p
		\}\bl
		\nl
		
		\func{HelpInsert}(\IFlag\ *$op$) \{\ul
		\n     \com {\it Precondition}:  $op$ points to an \IFlag\ \record\  (\ie, it is not $\NULL$)\nl
		\func{CAS-Child}$(op\rightarrow p, op\rightarrow l, op\rightarrow newInternal)$ \tabtabcom {\bf ichild \CAS}\label{ichild-cas}\nl
		$\CAS(op\rightarrow p\rightarrow update, \langle \insertflag, op \rangle, \langle \clean, op\rangle)$ \tabtabcom {\bf iunflag \CAS} \label{iunflag-cas}\nl
		\p
		\}
	\end{code}
	\caption{\label{code2}Pseudocode for \func{Search}, \func{Find} and \func{Insert}.}
\end{figure*}

\begin{figure*}
	\begin{code}
		\firstline
		\func{Delete}($\Key\ k$) : boolean \{\nl
		\n Internal *$gp$, *$p$\nl
		Leaf *$l$\nl
		Update $pupdate, gpupdate, result$\nl
		\DFlag\ *$op$\bl\nl
		while \TRUE\ \{ \nl
		\n     $\langle gp, p, l, pupdate, gpupdate \rangle := \func{Search}(k)$\label{del-search}\nl
		if $l\rightarrow key \neq k$ then return \FALSE\ \tabtabcom Key $k$ is not in the tree\label{delete-false}\nl
		%       assert: $gp$ points to an internal node\label{assert-gpnotnull}\nl
		if $gpupdate.state \neq \clean$ then \func{Help}$(gpupdate)$ \label{del-help-unclean-1}\nl
		else if $pupdate.state \neq \clean$ then \func{Help}$(pupdate)$\label{del-help-unclean-2}\nl
		else \{ \tabtabcom Try to flag $gp$\nl
		\n          $op :=$ pointer to a new \DFlag\ \record\  containing $\langle gp, p, l, pupdate \rangle$\label{new-DFlag}\nl
		$result := \CAS(gp\rightarrow update, gpupdate, \langle \deleteflag, op \rangle)$ \tabtabcom {\bf dflag \CAS}\label{dflag-cas}\nl
		if $result = gpupdate$ then \{ \tabtabcom \CAS\ successful \nl
		\n             if \func{HelpDelete}$(op)$ then return \TRUE \label{delete-true} \tabtabcom Either finish deletion or unflag\nl
		\p          \}\nl                 
		else \func{Help}$(result)$ \tabcom The dflag \CAS\ failed; help the operation that caused the failure \label{del-help-after-failure}\nl%; help operation that is in the way 
		\p     \}\nl
		\p \}\nl
		\p
		\}\bl
		\nl
		
		\func{HelpDelete}(\DFlag\ *$op$) : boolean \{\ul
		\n   \com {\it Precondition}:  $op$ points to a \DFlag\ \record\  (\ie, it is not \NULL)\nl%$op\rightarrow pupdate.state = \clean$\nl
		Update $result$ \tabtabcom Stores result of mark \CAS\bl\nl
		%\com First, try to mark the node that $op\rightarrow p$ points to\nl
		%$pupdate = op\rightarrow pupdate$\nl
		$result := \CAS(op\rightarrow p\rightarrow update, op\rightarrow pupdate, \langle \mk, op\rangle)$ \tabtabcom {\bf mark \CAS}\label{mark-cas}\nl     
		if $result = op\rightarrow pupdate$ or $result = \langle \mk, op\rangle$ then \label{checkmark}\{\tabtabcom $op\rightarrow p$ is successfully marked\nl
		\n          \func{HelpMarked}$(op)$ \label{call-hm1} \tabtabcom Complete the deletion\nl
		return \TRUE\tabtabcom Tell \func{Delete} routine it is done\nl
		\p       \}\nl
		else \{\tabtabcom The mark \CAS\ failed \nl
		\n              
		\func{Help}$(result)$\label{help-after-failed-mark}\tabtabcom Help operation that caused failure\nl
		\CAS$(op\rightarrow gp\rightarrow update, \langle \deleteflag, op\rangle, \langle \clean, op\rangle)$ \tabtabcom {\bf backtrack \CAS}\label{backtrack-cas}\nl
		
		return \FALSE\tabtabcom Tell \func{Delete} routine to try again\nl
		\p       \}\nl
		\p
		\}\bl
		\nl
		
		\func{HelpMarked}(\DFlag\ *$op$) \{\ul
		\n   \com {\it Precondition}:  $op$ points to a \DFlag\ \record\  (\ie, it is not $\NULL$)\nl
		Node *$other$\bl\ul
		\com Set $other$ to point to the sibling of the node to which  $op\rightarrow l$ points \nl
		if $op\rightarrow p\rightarrow right = op\rightarrow l$ then $other := op\rightarrow p \rightarrow \lft$ else $other:=op\rightarrow p\rightarrow right$\label{read-other}\ul 
		\com Splice the node to which $op\rightarrow p$ points out of the tree, replacing it by $other$\nl
		\func{CAS-Child}$(op\rightarrow gp, op\rightarrow p, other)$ \tabtabcom {\bf dchild \CAS}\label{dchild-cas}\nl
		%     \com Unflag the node $op\rightarrow gp$ points to\nl
		\CAS$(op\rightarrow gp\rightarrow update, \langle \deleteflag, op\rangle, \langle \clean, op\rangle)$ \tabtabcom {\bf dunflag \CAS}\label{dunflag-cas}\nl
		\p
		\}\bl\nl
		
		\func{Help}(Update $u$) \{ \tabtabcom General-purpose helping routine\ul
		\n    \com {\it Precondition}:  $u$ has been stored in the $update$ field of some internal node\nl
		if $u.state = \insertflag$ then \func{HelpInsert}$(u.\info)$\label{call-HelpInsert}\nl
		else if $u.state = \mk$ then \func{HelpMarked}$(u.\info)$\label{call-hm2}\nl
		else if $u.state = \deleteflag$ then \func{HelpDelete}$(u.\info)$\label{call-HelpDelete}\nl
		\p
		\}\bl
		\nl
		\func{CAS-Child}(Internal *$parent$, Node *$old$, Node *$new$) \{\label{CAS-Child}\ul
		\n  \com {\it Precondition}:  $parent$ points to an Internal node and $new$ points to a Node (\ie, neither is \NULL)\ul
		\com This routine tries to change one of the child fields of the node that $parent$ points to from $old$ to $new$.\nl
		if $new \rightarrow key < parent\rightarrow key$ then\label{which-child}\nl
		\n       \CAS$(parent\rightarrow \lft, old, new)$\label{child-cas-1}\nl
		\p  else\nl
		\n       \CAS$(parent\rightarrow right, old, new)$\label{child-cas-2}\nl
		\p\p 
		\}
	\end{code}
	\caption{\label{code3}Pseudocode for \func{Delete} and some auxiliary routines.}
\end{figure*}

\end{document}
	