


\def\codeTabSpace{\hspace*{6mm}}
\newenvironment{code}%
{\begin{tabbing}%
		\codeTabSpace \= \hspace*{70mm} \= \hspace*{42mm} \= \kill%
	}%
	{\end{tabbing}%
}
\newcounter{ind}
\newcommand{\n}{\addtocounter{ind}{7}\hspace*{7mm}}
\newcommand{\p}{\addtocounter{ind}{-7}\hspace*{-7mm}}
\newcommand{\nlc}{\\\stepcounter{linenum}{\scriptsize \arabic{linenum}}\>\hspace*{\value{ind}mm}}
\newcommand{\ul}{\\\>\hspace*{\value{ind}mm}}
\newcommand{\bl}{\\[-1.5mm]\>\hspace*{\value{ind}mm}}
\newcommand{\firstline}{\stepcounter{linenum}{\scriptsize \arabic{linenum}}\>}
\newcommand{\lref}[1]{\linenumref{#1}} % use this to refer to a line number
% End of stuff for entering source code=====================================

\newcommand{\postnotnull}{(1)}
\newcommand{\postl}{(2)}
\newcommand{\postpup}{(3)}
\newcommand{\postnonempty}{(4)}
\newcommand{\postgpnotnull}{(4a)}
\newcommand{\postp}{(4b)}
\newcommand{\postgpup}{(4c)}

\newcommand{\tabtabcom}{\>\>\com}
\newcommand{\tabcom}{\>\com}


\newcommand{\Key}{Key}
\newcommand{\R}{{\bf R}}
\newcommand{\NULL}{\mbox{$\bot$}}
\newcommand{\clean}{\mbox{\sc Clean}}
\newcommand{\mk}{\mbox{\sc Mark}}
\newcommand{\insertflag}{\mbox{I\Flag}}
\newcommand{\deleteflag}{\mbox{D\Flag}}
\newcommand{\record}{\mbox{record}}
\newcommand{\info}{\mbox{info}}

\newcommand{\Flag}{Flag}
\newcommand{\DFlag}{DInfo}
\newcommand{\IFlag}{IInfo}

\newcommand{\ie}{{\it i.e.}}
\newcommand{\TRUE}{\mbox{\sc True}}
\newcommand{\FALSE}{\mbox{\sc False}}

\newcommand{\func}[1]{\mbox{\sc #1}}

\newcommand{\CASB}{\func{CAS}}

\newcommand{\comnospace}{\mbox{$\triangleright$}}
\newcommand{\com}{\mbox{\comnospace\ }}

\newcommand{\doublespace}{\addtolength{\baselineskip}{.8\baselineskip}}
\newcommand{\ds}{\addtolength{\baselineskip}{.9\baselineskip}}

%%%%%%%%%%%%%%%%%%%%% COMMENTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%% New state-of-the-art method for comment insertion
%%%% by multiple distributed authors.
%%%% These comments are present in the LATEX file and
%%%% do not appear in print.
%
%% define debug: use first def for debug, second def for final version
\newcommand{\debug}[1]{#1}
%\newcommand{\debug}[1]{}
%

%% \newcommand{\comment}[1]{\debug{\marginpar {\sloppy\tiny #1}}}
\newcommand{\lcomment}[1]{\debug{\comment{$\rightarrow$ #1}}}
\newcommand{\incomment}[1]{\debug{[[[#1]]]}}
%
\newcommand{\fM}[1]{\comment{#1 5-14 M.}}
\newcommand{\fD}[1]{\comment{#1 5-21 D.}}
\newcommand{\upcom}[1]{#1}
%
%%%%%%%%%%%%%%%% end of comments %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\newenvironment{remark}{\begin{trivlist}
		\item[\hspace{\labelsep}{\bf\noindent Remark. }]}{\end{trivlist}}
%
%

\newenvironment{centre}{\begin{center}}{\end{center}}
% sets up centre as alternate name for center.



% marginal comment
\newcommand{\comment}[1]{\marginpar{\tiny #1}}
%\mnote{Example: only one algorithm is typed in so far.}
\newcommand{\mnote}[1]
{\marginpar%
	[{\tiny\begin{minipage}[t]{\marginparwidth}\raggedright#1%
	\end{minipage}}]%
	{\tiny\begin{minipage}[t]{\marginparwidth}\raggedright#1%
	\end{minipage}}%
}



%\newcommand{\here}[1]{[[[#1]]]\marginpar{***}}
\newcommand{\ignore}[1]{}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}

\newcommand{\lft}{\mbox{\it left}}




\section{Robust BST}

The original BST algorithm does not support the crash-recovery model. It is clear from the code a process does not persist the operation's response in the non-volatile memory, and thus, once a process crash the response is lost. For example, assume a process $q$ apply $\func{Insert} (k)$, performs a successful \CASB\ in line \lref{iflag-cas} and fails after completing the \func{HelpInsert} routine. In this case, the \func{Insert} operation took effect, that is, the new key appears as a leaf in the tree, and any $\func{Find} (k)$ operation will return it. However, even though the operation must be linearized before the crash, upon recovery process $q$ is unaware of it. Moreover, looking for the new leaf in the tree may be futile, as it might be $k$ has been removed from the tree after the crash.

Furthermore, if no recover routine is supplied, it may result an execution which is not well-formed. Consider for example the following scenario. A process $q$ invoke an $Op_1 = \func{Insert}(k_1)$ operation. $q$ performs a successful \CASB\ in line \lref{iflag-cas} followed by a crush. After recovering, $q$ invoke an $Op_2 = \func{Insert}(k_2)$ operation. Assume $k_1$ and $k_2$ belongs to a different parts of the tree (do not share parent or grandparent). Then, $q$ can complete the insertion of $k_2$ without having any affect on $k_1$. Now, a process $q'$ performs $\func{Find}(k_1)$ which returns \NULL, as the insertion of $k_1$ is not completed, followed by $\func{Find}(k_2)$, which returns the leaf of $k_2$. The $\func{Insert}(k_1)$ operation will be completed later by any \func{Insert} or \func{Delete} operation which needs to make changes to the flagged node. We get that $Op_2$ must be before $Op_1$ in the linearization, although $Op_1$ invoked first.

The kind of anomaly described above can be addressed by having the first \CASB\ of a successful attempt for \func{Insert} or \func{Delete} as the linearization point, as in the Linked-List. For that, the \func{Find} routine should take into consideration future unavoidable changes, for example, a node flagged with \insertflag\ ensures an insertion of some key. A simple solution is to change the \func{Find} routine such that it also helps other operations, as described in figure \ref{robust find - solution 1}. The \func{Find} routine will search for key $k$ in the tree. If the \func{Search} routine returns a grandparent or a parent that is flagged, then it might be that an insert or delete of $k$ is currently in progress, thus we first help the operation to complete, and then search for $k$ again. Otherwise, if $gpupdate$ or $pupdate$ has been changed since the last read, it means some change already took affect, and there is a need to search for $k$ again. If none of the above holds, there is a point in time where $gp$ points to $p$ which points to $l$, and there is no attempt to change this part of the tree. As a result, if $k$ is in the tree at this point, it must be in $l$, and the find can return safely. 

The approach described above is not efficient in terms of time. We would like a solution which maintain the desirable behaviour of the original \func{Find} routine, where a single \func{Search} is needed. A more refined solution is given in figure \ref{robust find - solution 2}. The intuition for it is drown from the Linked-List algorithm.
In the Linked-List algorithm it was enough to consider a marked node as if it has been deleted, without the need to complete the deletion. Nonetheless, the complex BST implementation is more challenging, as the \func{Delete} routine needs to successfully capture two nodes using \CASB\ in order to complete the deletion. Therefore, if a process $p$ executes $\func{Find}(k)$ procedure, and observes a node flagged with $\deleteflag$ attempting to delete the key $k$, it can not know whether in the future this delete attempt will succeed or fail, and thus does not know whether to consider the key $k$ as part of the tree or not. To overcome this problem, in such case the process will first try and validate the delete operation by marking the relevant node. According to whether the marking attempt was successful, the process can conclude if the delete operation is successful or not.
In order to easily implement the modified \func{Find} routine there is a need to conclude from \IFlag\ what is the new leaf (leaf $new$ in the \func{Insert} routine). For simplicity of presentation, we do not add this field, and abstractly refer to it in the code.

The correctness of the two suggested solutions relies on the following argument.
Once a process flags a node during operation $Op$ with input key $k$ (either \func{Insert} or \func{Delete}), then if this attempt to complete the operation eventually succeed (i.e., the marking is also successful in the case of \func{Delete}), then any \func{Find}(k) operation invoked from this point consider $Op$ as if it is completed.

The suggested modification, although being simple and local, only guarantee the implementation satisfy R-linearzability. However, the problem of response being lost in case of a crash is not addressed. Roughly speaking, the critical points in the code for recovery are the \CASB\ primitives, as a crash right after applying \CASB\ operation results the lost of the response, and in order to complete the operation the process needs to know the result of the \CASB. In addition, because of the helping mechanism, a suspended \func{Delete} operation which flagged a node and yet to mark one, may be completed by other process in the future, and may not. Upon recovery, the process needs to distinguish between the two cases, in order to obtain the right response.

To address this issue, we expend the helping mechanism, so that the helping process needs also to update the info structure in case of a success. This is done by adding a boolean field to the Flag structure. This way, if a process crash along an operation $Op$, upon recovery it can check whether the operation was completed by some different process. 

Before a process attempt to perform an operation, as it creates the \Flag\ structure $op$ describing the operation and its affect on the data structure, the process stores $op$ in a designated location (for simplicity, we use an array). Upon recovery, the process reads this location, and if the operation is not completed yet, it retries to perform it, starting from the point of the first flagging (the first \CASB). Otherwise, the operation was completed, and the response value is already known. Notice that there is a scenario in which process $q$ recovers and observes an operation $Op$ as not being completed, but just before it retries it, some other process complete the operation. We need to prove that even in such case, the operation will affect the data structure exactly once, and the right response is returned.

Notice that the given implementation does not recover the \func{Find} routine, since this routine does not make any changes to the BST, hence it is always safe to consider it as having no linearization point and reissue it. Also, for ease of presentation, we only write to Announce[id] once we are about to capture a node using a CAS. However, writing to Announce[id] at the beginning of the routine may be helpful in case of a crash early in the routine, so that the process will be able to use the data stored in Announce[id] in such case also. The same is true with response value - Announce[id].done is updated only if the routine made changes to the BST.

\subsubsection{Correctness}

In this subsection we give a proof sketch for the algorithm correctness. We assume for simplicity nodes and \Flag\ records are always allocated new memory locations, although it is enough to require no location is reallocated as long as there is a chain of pointers leading to it. The proof relies on the correctness of the original algorithm, which can be found on [....]. Moreover, the original algorithm is anonymous and uniform, i.e., any number of processes can use the BST, and there is no need to know the number of processes in the system in order to use the BST. Thus, if we consider an execution and prove it is indistinguishable to a process $q$ from some execution of the original algorithm in which more processes can participate, then it has to return the same response on both.
The proof relies on several key arguments given below.

\newcommand{\argSearch}{argument 1}
1. It is easy to verify the post-conditions of the \func{Search} routine still holds, as they follow directly from the code. Also, since no changes are made to the \func{Search} routine, it does not make any changes to the BST, but rather simply traverse it. Therefore \func{Find} routine, which only uses \func{Search}, does not affect any process, and in case of a failure along \func{Find} execution, reissuing it satisfies NRL.

\newcommand{\argNodeRef}{argument 2}
2. If an internal node $nd_1$ stops pointing to a node $nd_2$ at some point of the execution, it can not point to $nd_2$ again. This attributes to the fact an \func{Insert} presents a node with two new children. Therefore, if $nd_2$ is a leaf, it can either be deleted, or replace with a new copy when an insert operation takes affect. Otherwise, $nd_2$ is an internal node, and as such, it can not be replaced by an insert operation (which only allows to replace a leaf), and therefore it can only be removed from the tree.

\newcommand{\argNodeUpdate}{argument 3}
3. The field update of a node $nd$ can have any value only once along the execution. This follows from the fact that any attempt to perform an operation creates new record in the memory. If $nd\leftarrow update$ is marked, it can be unmarked or change. Otherwise, any attempt to flag it uses a new created record $op$. If the attempt succeed, then eventually it will be unflagged while still referring to $op$. In order to replace the value again, there must be an operation reading $nd\leftarrow update$ after it was unflagged (as any operation first help a flagged node). This operation must create a new record, and thus we can use the same argument. As a corollary, if a process successfully flag or mark a node, there was no change in the node since the last time it read the node update field.



Assume process $q$ performs an \func{Insert}(k) operation. As argued in \argSearch, a crash before writing to Announce[q] implies no changes has been made to the BST. Assume thus $q$ executes line \lref{insert-write-announce}, i.e., $q$ stored in Announce[q] a pointer to an \IFlag\ record containing all the data needed for the current attempt to complete the \func{Insert} routine. Since $q$ is in the middle of a while loop, it is enough to prove that if $q$ crash before the next time it writes to Announce[q], if there is such write, upon recovery it will either complete its operation with the right response, or will continue to the next write to Announce[q] without having any affect on the BST. Hence, the same argument can be applied once $q$ writes to Announce[q] again.

Assume $q$ performs a successful CAS in line \lref{iflag-cas}. Then, a reference to the \IFlag\ $op$ is stored in $p\leftarrow update$, which is also flagged. Following \argNodeUpdate, $p$ was not changed since the \func{Search} routine read it, and it still points to $l$.
Starting from this point, no changes can be made to $p$, except for the change point to by $op$, as the node is flagged. Now, only the first process 

Relying on the correctness of the original algorithm, no matter how many times \func{HelpInsert}(op) will be executed, the change will occur only once. This follows from the fact that many process can observe op, and will try to complete it in the future. The core for this argument is that a node never point twice to the same node.








%\setcounter{linenum}{0}


\begin{figure*}[h]
	\footnotesize
	
	\begin{code}
		\func{Find}($\Key\ k$) : Leaf* \{ \nlc
		\n Internal *$gp$, *$p$\nlc
		Leaf *$l$\nlc
		Update $pupdate, gpupdate$\bl
		\nlc
		
		%     Update $pupdate,gpupdate$\ul \nlc
		while (\TRUE) \{ \nlc \n
		$\langle gp, p, l, pupdate, gpupdate \rangle := \func{Search}(k)$\nlc
		if $gpupdate.state \neq \clean$ then $\func{Help}(gpupdate)$ \nlc
		else if $pupdate.state \neq \clean$ then $\func{Help}(pupdate)$ \nlc
		else if $gp \leftarrow update = gpupdate$ and $p \leftarrow update = pupdate$ then \{ \nlc \n
		if $l \rightarrow key = k$ then return $l$ \nlc
		else return \NULL \nlc
		\p \} \nlc
		\p \} \nlc
		\p \}
	\end{code}
	
	\caption{Solution 1: R-linearizable \func{Find} routine}
	\label{robust find - solution 1}
\end{figure*}



\begin{figure*}[h]
	\footnotesize
	
	\begin{code}
		\func{Find}($\Key\ k$) : Leaf* \{ \nlc
			\n Internal *$gp$, *$p$\nlc
			Leaf *$l$\nlc
			Update $pupdate, gpupdate$\bl
			\nlc
			
			%     Update $pupdate,gpupdate$\ul \nlc
			$\langle gp, p, l, pupdate, gpupdate \rangle := \func{Search}(k)$\nlc
			if $l\rightarrow key \neq k$ then \{ \nlc
				\n if ($pupdate.state = \insertflag$ and $pupdate.info$ attempt to add key $k$) then \nlc
					\n return leaf with key $k$ from $pupdate.info$ \nlc \p
				else return \NULL \nlc \p
			\} \nlc
			if ($pupdate.state = \mk$ and $pupdate.info \leftarrow l \leftarrow key = k$) then return \NULL \nlc
			if ($gpupdate.state = \deleteflag$ and $gpupdate.info \leftarrow l \leftarrow key = k$) then \{ \nlc
				\n $op := gpupdate.info$ \nlc
				$result := \CASB(op\rightarrow p\rightarrow update, op\rightarrow pupdate, \langle \mk, op\rangle)$ \tabtabcom {\bf mark \CASB}\label{mark-cas}\nlc     
				if ($result = op\rightarrow pupdate$ or $result = \langle \mk, op\rangle$) then return \NULL \label{checkmark} \tabtabcom $op\rightarrow p$ is successfully marked \nlc \p
			\} \nlc
			return $l$ \nlc \p
		\}
	\end{code}

	\caption{Solution 2: R-linearizable \func{Find} routine}
	\label{robust find - solution 2}
\end{figure*}




\begin{figure}[bt]
	\footnotesize
	\begin{code}
		\firstline
		type Update \{ \hspace*{14mm} \com stored in one CAS word\nlc
		\n  $\{\clean,\deleteflag,\insertflag,\mk\}$ $state$ \nlc
		\Flag\ *{\it info}\nlc
		\p
		\}
		\nlc
		type Internal \{ \hspace*{13.25mm} \com subtype of Node\nlc
		\n $\Key \cup \{\infty_1,\infty_2\}$ $key$\nlc
		Update $update$\nlc
		Node *\lft, *$right$\nlc
		\p\}
		\nlc
		type Leaf \{ \hspace*{18.3mm} \com subtype of Node\nlc
		%\hspace*{4mm} \com could also store auxiliary information\nlc 
		\n $\Key \cup \{\infty_1,\infty_2\}$  $key$\nlc
		\p\}
		\nlc
		type \IFlag\ \{ \hspace*{17.7mm} \com subtype of \Flag\nlc
		\n Internal *$p$, *$newInternal$\nlc
		Leaf *$l$\nlc
		\textcolor{blue}{\{\clean,\deleteflag,\insertflag,\mk, \TRUE\} $done$} \nlc
		\p\}
		\nlc
		type \DFlag\ \{ \hspace*{16.4mm} \com subtype of \Flag\nlc
		\n Internal *$gp$, *$p$\nlc
		Leaf *$l$\nlc
		Update $pupdate$\nlc
		\textcolor{blue}{\{\clean,\deleteflag,\insertflag,\mk, \TRUE\} $done$} \nlc
		\p\}   
		\ul
		\com Initialization:\nlc
		shared Internal *$Root$ := pointer to new Internal node \ul
		\n with $key$ field $\infty_2$, $update$ field $\langle \clean,\NULL\rangle$, and\ul
		pointers to new Leaf nodes with keys $\infty_1$ and\ul 
		$\infty_2$, respectively, as \lft\ and $right$ fields.
		\p 
	\end{code}
	\caption{\label{code1}Type definitions and initialization.}
\end{figure}



\begin{figure*}
	\footnotesize
	
	\begin{code}
		\func{Recover}() \{ \nlc \n
			Flag $*op$ = Announce[id] \bl \nlc
			
			if $op \leftarrow done = \TRUE$ then return \TRUE \nlc
			if $op$ of type \IFlag\ then \nlc \n
				go to line \lref{iflag-cas} \nlc \p
			if $op$ of type \DFlag\ then \nlc \n
				go to line \lref{dflag-cas} \nlc \p
		\p \}
	\end{code}

\caption{\func{Recover} routine}
\end{figure*}



\begin{figure*}
	\scriptsize
	\begin{code}
		\firstline
		\func{Search}($\Key\ k$) : $\langle \mbox{Internal*}, \mbox{Internal*}, \mbox{Leaf*}, \mbox{Update}, \mbox{Update}\rangle$  \{\ul
		\n \com Used by \func{Insert}, \func{Delete} and \func{Find} to traverse a branch of the BST; satisfies following {\it postconditions}:\ul
		\com \postnotnull\ $l$ points to a Leaf node and $p$ points to an Internal node\ul
		\com \postl\ Either $p\rightarrow \lft$ has contained $l$ (if $k<p\rightarrow key$) or $p\rightarrow right$ has contained $l$ (if $k\geq p\rightarrow key$)\ul
		\com \postpup\ $p\rightarrow update$ has contained $pupdate$\ul
		\com \postnonempty\ if $l\rightarrow key\neq \infty_1$, then the following three statements hold:\ul
		\com \hspace*{3mm}\postgpnotnull\ $gp$ points to an Internal node\ul
		\com \hspace*{3mm}\postp\ either $gp\rightarrow \lft$ has contained $p$ (if $k<gp\rightarrow key$) or $gp\rightarrow right$ has contained $p$ (if $k\geq gp\rightarrow key$)\ul
		\com \hspace*{3mm}\postgpup\ $gp\rightarrow update$ has contained $gpupdate$\nlc
		Internal *$gp$, *$p$\nlc
		Node *$l:= Root$  \label{restart-search}\nlc
		
		Update $gpupdate, pupdate$ \tabtabcom Each stores a copy of an $update$ field\bl\nlc
		%\com The initial values of $p,gp,pupdate$ and $gpupdate$ are unimportant
		%$p :=\NULL$ 
		%$pupdate := \langle \clean, \NULL\rangle$\nlc
		while $l$ points to an internal node \{ \nlc%\com Advance down the tree\nlc
		\n         $gp := p$ \tabtabcom Remember parent of $p$\nlc
		$p := l$ \tabtabcom Remember parent of $l$\nlc
		$gpupdate := pupdate$ \tabtabcom Remember $update$ field of $gp$\nlc
		$pupdate := p\rightarrow update$\label{store-pupdate}\tabtabcom Remember $update$ field of $p$\nlc  
		%           if $pupdate.state = \mk$ then \label{checkmark} \{\nlc
		%\n              \func{HelpMarked}$(pupdate.info)$ \label{call-hm3}\nlc
		%                goto line \lref{restart-search} \com Restart traversal\nlc
		%\p         \}\nlc        
		if $k < l\rightarrow key$ then $l:= p\rightarrow \lft$ else $l:=p \rightarrow right$ \label{read-child}\tabtabcom Move down to appropriate child\nlc
		%           if $pupdate \neq p\rightarrow update$ then goto line \lref{restart-search} \com Restart traversal \label{reread-pupdate}\nlc
		\p \} \nlc
		return $\langle gp, p, l, pupdate, gpupdate \rangle$ \nlc
		\p 
		\}\bl
		\nlc
		\func{Find}($\Key\ k$) : Leaf* \{ \nlc
		\n   Leaf *$l$\bl
		\nlc
		%     Update $pupdate,gpupdate$\ul \nlc
		$\langle -,-,l,-,-\rangle := \func{Search}(k)$\nlc
		if $l\rightarrow key = k$ then return $l$\nlc
		else return \NULL\nlc
		\p
		\}\bl
		\nlc
		\func{Insert}($\Key\ k$) : boolean \{ \nlc
		\n Internal *$p$, *$newInternal$\nlc 
		Leaf *$l$, *$newSibling$\nlc 
		Leaf *$new :=$ pointer to a new Leaf node whose $key$ field is $k$  \nlc
		Update $pupdate, result$\nlc
		\IFlag\ *$op$\bl\nlc%:=$ pointer to a new \IFlag\ \record\ \ul\nlc
		while \TRUE\ \{  \nlc
		\n $\langle -, p, l, pupdate, - \rangle := \func{Search}(k)$ \label{ins-search}\nlc
		if $l \rightarrow key = k$ then return \FALSE\ \tabtabcom Cannot insert duplicate key\label{insert-false}\nlc
		if $pupdate.state \neq \clean$ then \func{Help}$(pupdate)$ \tabtabcom Help the other operation \label{ins-help-unclean}\nlc
		else \{\nlc
		\n        $newSibling :=$ pointer to a new Leaf whose key is $l\rightarrow key$\nlc
		$newInternal :=$ pointer to a new Internal node with $key$ field $\max(k, l \rightarrow key)$,\label{create-internal}\ul      
		\n      $update$ field $\langle \clean, \NULL\rangle$, and with two
		child fields equal to $new$ and $newSibling$\ul 
		(the one with the smaller key is the left child)\nlc
		\p        $op :=$ pointer to a new \IFlag\ \record\  containing $\langle p, l, newInternal, \textcolor{blue}{\clean}\rangle$\label{new-IFlag}\nlc
		\textcolor{blue}{$Announce[id] := op$} \label{insert-write-announce} \nlc
		$result := \CASB(p\rightarrow update, pupdate, \langle \insertflag, op\rangle)$ \tabtabcom {\bf iflag \CASB}\label{iflag-cas} \nlc
		if $result = pupdate$ \textcolor{blue}{or $result = \langle \insertflag,op \rangle$} then \{ \tabtabcom The iflag \CASB\ was successful\nlc
		\n            \func{HelpInsert}$(op)$ \tabtabcom Finish the insertion\label{finish-insert}\nlc
		return \TRUE\ \label{insert-true}\nlc
		\p        \}\nlc 
		else \func{Help}$(result)$ \tabcom The iflag \CASB\ failed; help the operation that caused failure\label{ins-help-after-failure}\nlc
		\p    \}\nlc
		\textcolor{blue}{if $op \rightarrow done = \TRUE$ then} \nlc
		\n		\textcolor{blue}{return \TRUE} \nlc \p
		\p\}\nlc 
		\p
		\}\bl
		\nlc
		
		\func{HelpInsert}(\IFlag\ *$op$) \{\ul
		\n     \com {\it Precondition}:  $op$ points to an \IFlag\ \record\  (\ie, it is not $\NULL$)\nlc
		\textcolor{blue}{$op \rightarrow done := \insertflag$} \tabtabcom {announce the iflag \CASB\ was successful}\nlc 
		\func{CAS-Child}$(op\rightarrow p, op\rightarrow l, op\rightarrow newInternal)$ \tabtabcom {\bf ichild \CASB}\label{ichild-cas}\nlc
		$\CASB(op\rightarrow p\rightarrow update, \langle \insertflag, op \rangle, \langle \clean, op\rangle)$ \tabtabcom {\bf iunflag \CASB} \label{iunflag-cas}\nlc
		\textcolor{blue}{$op \rightarrow done := \TRUE$} \tabtabcom {announce the operation is completed}\nlc 
		\p
		\}
	\end{code}
	\caption{\label{code2}Pseudocode for \func{Search}, \func{Find} and \func{Insert}.}
\end{figure*}

\begin{figure*}
	\scriptsize
	\begin{code}
		\firstline
		\func{Delete}($\Key\ k$) : boolean \{\nlc
		\n Internal *$gp$, *$p$\nlc
		Leaf *$l$\nlc
		Update $pupdate, gpupdate, result$\nlc
		\DFlag\ *$op$\bl\nlc
		while \TRUE\ \{ \nlc
		\n     $\langle gp, p, l, pupdate, gpupdate \rangle := \func{Search}(k)$\label{del-search}\nlc
		if $l\rightarrow key \neq k$ then return \FALSE\ \tabtabcom Key $k$ is not in the tree\label{delete-false}\nlc
		%       assert: $gp$ points to an internal node\label{assert-gpnotnull}\nlc
		if $gpupdate.state \neq \clean$ then \func{Help}$(gpupdate)$ \label{del-help-unclean-1}\nlc
		else if $pupdate.state \neq \clean$ then \func{Help}$(pupdate)$\label{del-help-unclean-2}\nlc
		else \{ \tabtabcom Try to flag $gp$\nlc
		\n          $op :=$ pointer to a new \DFlag\ \record\  containing $\langle gp, p, l, pupdate, \textcolor{blue}{\clean} \rangle$\label{new-DFlag}\nlc
		\textcolor{blue}{$Announce[id] := op$} \nlc
		$result := \CASB(gp\rightarrow update, gpupdate, \langle \deleteflag, op \rangle)$ \tabtabcom {\bf dflag \CASB}\label{dflag-cas}\nlc
		if $result = gpupdate$ \textcolor{blue}{ or $result = \langle \deleteflag, op \rangle$} then \{ \tabtabcom \CASB\ successful \nlc
		\n             if \func{HelpDelete}$(op)$ then return \TRUE \label{delete-true} \tabtabcom Either finish deletion or unflag\nlc
		\p          \}\nlc                 
		else \func{Help}$(result)$ \tabcom The dflag \CASB\ failed; help the operation that caused the failure \label{del-help-after-failure}\nlc%; help operation that is in the way 
		\p     \}\nlc
		\textcolor{blue}{if $op \rightarrow done = \TRUE$ then} \nlc
		\n		\textcolor{blue}{return \TRUE} \nlc \p
		\p \}\nlc
		\p
		\}\bl
		\nlc
		
		\func{HelpDelete}(\DFlag\ *$op$) : boolean \{\ul
		\n   \com {\it Precondition}:  $op$ points to a \DFlag\ \record\  (\ie, it is not \NULL)\nlc%$op\rightarrow pupdate.state = \clean$\nlc
		Update $result$ \tabtabcom Stores result of mark \CASB\bl\nlc
		%\com First, try to mark the node that $op\rightarrow p$ points to\nlc
		%$pupdate = op\rightarrow pupdate$\nlc
		$result := \CASB(op\rightarrow p\rightarrow update, op\rightarrow pupdate, \langle \mk, op\rangle)$ \tabtabcom {\bf mark \CASB}\label{mark-cas}\nlc     
		if $result = op\rightarrow pupdate$ or $result = \langle \mk, op\rangle$ then \label{checkmark}\{\tabtabcom $op\rightarrow p$ is successfully marked\nlc
		\n          \func{HelpMarked}$(op)$ \label{call-hm1} \tabtabcom Complete the deletion\nlc
		return \TRUE\tabtabcom Tell \func{Delete} routine it is done\nlc
		\p       \}\nlc
		else \{\tabtabcom The mark \CASB\ failed \nlc
		\n              
		\func{Help}$(result)$\label{help-after-failed-mark}\tabtabcom Help operation that caused failure\nlc
		\CASB$(op\rightarrow gp\rightarrow update, \langle \deleteflag, op\rangle, \langle \clean, op\rangle)$ \tabtabcom {\bf backtrack \CASB}\label{backtrack-cas}\nlc
		
		return \FALSE\tabtabcom Tell \func{Delete} routine to try again\nlc
		\p       \}\nlc
		\p
		\}\bl
		\nlc
		
		\func{HelpMarked}(\DFlag\ *$op$) \{\ul
		\n   \com {\it Precondition}:  $op$ points to a \DFlag\ \record\  (\ie, it is not $\NULL$)\nlc
		Node *$other$\bl\ul
		\com Set $other$ to point to the sibling of the node to which  $op\rightarrow l$ points \nlc
		if $op\rightarrow p\rightarrow right = op\rightarrow l$ then $other := op\rightarrow p \rightarrow \lft$ else $other:=op\rightarrow p\rightarrow right$\label{read-other}\ul 
		\com Splice the node to which $op\rightarrow p$ points out of the tree, replacing it by $other$\nlc
		\func{CAS-Child}$(op\rightarrow gp, op\rightarrow p, other)$ \tabtabcom {\bf dchild \CASB}\label{dchild-cas}\nlc
		%     \com Unflag the node $op\rightarrow gp$ points to\nlc
		\CASB$(op\rightarrow gp\rightarrow update, \langle \deleteflag, op\rangle, \langle \clean, op\rangle)$ \tabtabcom {\bf dunflag \CASB}\label{dunflag-cas}\nlc
		\textcolor{blue}{$op \rightarrow done := \TRUE$} \tabtabcom {mark the operation as completed} \nlc
		\p
		\}\bl\nlc
		
		\func{Help}(Update $u$) \{ \tabtabcom General-purpose helping routine\ul
		\n    \com {\it Precondition}:  $u$ has been stored in the $update$ field of some internal node\nlc
		if $u.state = \insertflag$ then \func{HelpInsert}$(u.\info)$\label{call-HelpInsert}\nlc
		else if $u.state = \mk$ then \func{HelpMarked}$(u.\info)$\label{call-hm2}\nlc
		else if $u.state = \deleteflag$ then \func{HelpDelete}$(u.\info)$\label{call-HelpDelete}\nlc
		\p
		\}\bl
		\nlc
		\func{CAS-Child}(Internal *$parent$, Node *$old$, Node *$new$) \{\label{CAS-Child}\ul
		\n  \com {\it Precondition}:  $parent$ points to an Internal node and $new$ points to a Node (\ie, neither is \NULL)\ul
		\com This routine tries to change one of the child fields of the node that $parent$ points to from $old$ to $new$.\nlc
		if $new \rightarrow key < parent\rightarrow key$ then\label{which-child}\nlc
		\n       \CASB$(parent\rightarrow \lft, old, new)$\label{child-cas-1}\nlc
		\p  else\nlc
		\n       \CASB$(parent\rightarrow right, old, new)$\label{child-cas-2}\nlc
		\p\p 
		\}
	\end{code}
	\caption{\label{code3}Pseudocode for \func{Delete} and some auxiliary routines.}
\end{figure*}