
\newcommand{\push}{\mbox{\sc Push}}
\newcommand{\trypush}{\mbox{\sc TryPush}}
\newcommand{\recoverPush}{\mbox{\sc Push-Roceover}}
\newcommand{\pop}{\mbox{\sc Pop}}
\newcommand{\trypop}{\mbox{\sc TryPop}}
\newcommand{\recoverPop}{\mbox{\sc Pop-Recover}}
\newcommand{\recover}{\mbox{\sc Recover}}
\newcommand{\exchange}{\mbox{\sc Exchange}}
\newcommand{\recoverExchange}{\mbox{\sc Exchange-Recover}}
\newcommand{\visit}{\mbox{\sc Visit}}
\newcommand{\switchPair}{\mbox{\sc SwitchPair}}


\newcommand{\init}{\mbox{$\bot$}}
\newcommand{\NULL}{\mbox{\sc Null}}
\newcommand{\fail}{\mbox{\sc Fail}}
\newcommand{\emptyst}{\mbox{\sc Empty}}
\newcommand{\waiting}{\mbox{\sc Waiting}}
\newcommand{\busy}{\mbox{\sc Busy}}
\newcommand{\timeout}{\mbox{\sc Timeout}}

\newcommand{\Info}{\mbox{Info}}
\newcommand{\opInfo}{\mbox{OpInfo}}
\newcommand{\exInfo}{\mbox{ExInfo}}


\newcommand{\comnospace}{\mbox{$\triangleright$}}
\newcommand{\com}{\mbox{\comnospace\ }}
\newcommand{\tabtabcom}{\>\>\com}
\newcommand{\tabcom}{\>\com}


\section{Elimination Stack}

For simplicity, we assume a value \init, which is different from \NULL\ and any other value the stack can store. Since \NULL\ is used as a legit return value, representing the value of \pop\ operation (when exchanging values using the elimination array), \NULL\ can not be used to represent an initialization value, different then any stack value. The same holds for a Node, since a \NULL\ node represent an empty stack, the value \init\ is used to distinguish between initialization value and empty stack.

For simplicity, we split the \recover\ routine into sub-routines, based on which operation (\push, \pop, \exchange) is pending, or needs to be recover. This can be concluded easily by the type of record stored in $Announce[pid]$ (\exInfo\ or \opInfo), thus there is no need to explicitly know where exactly in the code the crash took place. Also, the \recover\ routine returns \fail\ in case the last pending operation did not took affect (no linearization point), nor it will take in any future run. In such case, the user has the option to either re-invoke the operation, or to skip it, depends on the needs and circumstances of the specific use of the data structure.

The given implementation ignores the log of failures and successes of the exchange routine when recovering. That is, in case of a crash during an \exchange, a process is able to recover the \exchange\ routine, however, the log of successes and failures is not update, since it might be the process already updated it. In addition, in case of a \fail\ response, we do not know whether the time limit (timeout) was reached, or that the process simply crashed earlier in the routine without completing it. The given implementation can be expanded to also consider the log. Nonetheless, for ease of presentation we do not handle the log in case of a crash. Assuming crash events are rare, the log still gives a roughly good approximation to the number of failures and successes, thus our approach might be useful in practice.

\subsection{A Lock-Free Exchanger}
An exchanger object supports the \exchange\ procedure, which allows 



\begin{figure*}[b]
	\small
	
	Type Node \{ \\
		\hspace*{6mm} T $value$ \\
		\hspace*{6mm} int $popby$ \\
		\hspace*{6mm} Node $*next$ \\
	\} \\
	
	
	Type \opInfo \{ \hspace*{17.7mm} $\triangleright$ subtype of \Info \\
		\hspace*{6mm} \{\push, \pop\} $optype$ \\
		\hspace*{6mm} Node $*curr$ \\
		\hspace*{6mm} boolean $done$ \\
	\} \\
	
	
	Type \exInfo \{ \hspace*{17.7mm} $\triangleright$ subtype of \Info \\
	\hspace*{6mm} \{\emptyst, \waiting, \busy\} $state$ \\
	\hspace*{6mm} T $value, result$ \\
	\hspace*{6mm} \exInfo\ $*partner, *slot$ \\
	\}
	
	\caption{Type definition}
\end{figure*}



%%%%%%%%%%%%%%%%%%Elimination array%%%%%%%%%%%%%%%%%
\begin{figure*}
	\small
	
	\exInfo\ $default$ - a global static \exInfo\ object with state = \emptyst
	
\begin{algorithm}[H]
	\caption{T \exchange\ (\exInfo\ $*slot$, T $myitem$, long $timeout$)}
	
	long $timeBound$ := getNanos() + $timeout$ \;
	\exInfo\ $myop$ := new \exInfo (\waiting, $myitem$, \init, \init, $slot$)\;
	$Announce[pid]$ := $myop$ \;
	
	\While{\True} {
		\uIf{getNanos() $> timeBound$} {
			$myop.result := \timeout$ \tcp*{time limit reached}
			\KwRet \timeout 
		}
		%$myop.state$ := \waiting \tcp*{set to default state}
		$yourop := slot$ \;
%		$\langle$youritem,state$\rangle$ := slot\;
		\Switch{$yourop.state$} {
			\uCase{\emptyst} {
				$myop.state$ := \waiting \tcp*{try to replace $default$}
				$myop.partner := \init$ \;
				\If {$slot.\CAS (yourop, myop)$} {
					\While{getNanos() $< timeBound$}{
						$yourop := slot$ \;
						\uIf(\tcp*[f]{a collision was done}) {$yourop \neq myop$} {
							\uIf (\tcp*[f]{$yourop$ collide with $myop$}) {$youop.parnter = myop$} {
								\switchPair $(myop, yourop)$ \;
								$slot.\CAS (yourop, default)$ \tcp*{release $slot$}
							}
							\KwRet $myop.result$ \;
						}
					}
					\tcp{time limit reached and no process collide with me}
					\uIf (\tcp*[f]{try to release $slot$}) {$slot.\CAS(myop, default)$}{
						$myop.result := \timeout$ \;
						\KwRet \timeout\;
					} \uElse (\tcp*[f]{some process show up}) {
						$yourop := slot$ \;
						\uIf{$yourop.partner = myop$} {
							\switchPair $(myop, yourop)$ \tcp*{complete the collision}
							$slot.\CAS (yourop, default)$ \tcp*{release $slot$}
						}
						\KwRet $myop.result$ \;
					}
				}
				break \;
			}
			\uCase (\tcp*[f]{some process is waiting in $slot$}){\waiting} {
				$myop.partner := yourop$ \tcp*{attempt to replace $yourop$}
				$myop.state := \busy$ \;
				\uIf (\tcp*[f]{try to collide}){$slot.\CAS (yourop, myop)$} {
					\switchPair $(myop, yourop)$ \tcp*{complete the collision}
					$slot.\CAS (myop, default)$ \tcp*{release $slot$}
					\KwRet $myop.result$ \;
				}
				break \;
			}
			\uCase (\tcp*[f]{a collision in progress}) {\busy} {
				\switchPair $(yourop, yourop.parnter)$ \tcp*{help to complete the collision}
				$slot.\CAS (yourop, default)$ \tcp*{release $slot$}
				break \;
			}
		}	
	} 
\end{algorithm}

\end{figure*}




\begin{figure*}
	\small
	
\begin{algorithm}[H]
	\caption{void \switchPair (\exInfo\ $first$, \exInfo\ $second$)}
	
	\tcp{exchange the valus of the two operations}
	$first.result := second.value$ \;
	$second.result := first.value$ \;
	
\end{algorithm}

\begin{algorithm}[H]
	\caption{T \visit\ (T $value$, int $range$, long $duration$)}
	
	\tcp{invoke \exchange\ on a random selected entery in the collision array}
	int $cell$ := randomNumber$(range)$ \;
	\KwRet \exchange$(exchanger[cell], value, duration)$
\end{algorithm}

\begin{algorithm}[H]
	\caption{T \recoverExchange\ $()$}
	
	\exInfo\ $*myop := Announce[pid]$ \tcp*{read your last operation record,}
	\exInfo\ $*slot := myop.slot$ \tcp*{and the slot on which it act}
	
	\uIf {$myop.state = \waiting$} {
		\tcp{crash while trying to exchange $defualt$, or waiting for a process to collide with me}
		$yourop := slot$ \;
		\uIf (\tcp*[f]{still waiting for a collide}) {$yourop = myop$} {
			\uIf (\tcp*[f]{try to release $slot$}){$slot.\CAS(myop, default)$}{\KwRet \fail}
			\uElse (\tcp*[f]{some process show up}) {
				$yourop := slot$ \;
				\uIf{$yourop.partner = myop$} {
					\switchPair$(myop, yourop)$ \tcp*{complete the collision}
					$slot.\CAS (yourop, default)$ \tcp*{release $slot$}
				}
				\KwRet $myop.result$ \;
				%\textbf{go to} \ref{ExRecover-successful} \;
			}	
		}
		\uIf (\tcp*[f]{$yourop$ collide with $myop$}) {$yourop.partner = myop$} {
			\switchPair$(myop, yourop)$ \tcp*{complete the collision}
			$slot.\CAS (yourop, default)$ \tcp*{release $slot$}
			\KwRet $myop.result$ \;
		}
		%\uIf {$myop.result \neq \init$} {\KwRet $myop.result$ \;}
		%\KwRet \fail	
	}
	\uIf {$myop.state = \busy$} {
		\tcp{crash while trying to collide with $myop.partner$}
		$yourop := slot$ \;
		\uIf (\tcp*[f]{collide was successful}) {$yourop = myop$} {
			\switchPair$(myop, myop.partner)$ \tcp*{complete the collision}
			$slot.\CAS (myop, default)$ \tcp*{release $slot$}
			\KwRet $myop.result$ \;
			%\textbf{go to} \ref{ExRecover-successful} \;
		}	
	}
	\uIf {$myop.result \neq \init$} {
		\KwRet $myop.result$ \tcp*{collide was successfuly completed}
	}
	\uElse {\KwRet \fail}

	\remove{
	returnCode: \tcp*{successful exchange} \label{ExRecover-successful}
	\uIf {exactly one of \{myop.value, myop.result\} is \NULL}
		{KwRet myop.result \tcp*[f]{Exchange of \push and \pop}}
	\uElse {\KwRet \fail \tcp*[f]{Exchange of two operations of the same type}}
	}
\end{algorithm}

\caption{Elimination Array routines}
\end{figure*}



%%%%%%%%%%%%%%%%%%PUSH%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}
	
\begin{algorithm}[H]
	\caption{boolean \trypush\ (Node $*new$)}
	
	Node $*oldTop := Top$\;
	$new.next := oldTop$\;
	\KwRet $Top.\CAS(oldTop, new)$
\end{algorithm}

\begin{algorithm}[H]
	\caption{boolean \push\ (T $myitem$)}
	
	Node $*nd$ = new Node $(myitem)$ \;
	$nd.popby := \init$ \;
	
	\opInfo\ $data$ := new \opInfo\ (\push, $nd$, \False) \;
	\While{\True}{
		$Announce[pid] := data$ \;
		\uIf{\trypush$(nd)$}{
			$data.done := \True$ \;
			\KwRet \True
		}
		$range$ := CalculateRange()\;
		$duration$ := CalculateDuration()\;
		$othervalue$ := \visit$(myitem, range, duration)$\;
		\uIf{$othervalue = \NULL$}{
			RecordSuccess ()\;
			\KwRet \True\;
		} \uElseIf {$othervalue = \timeout$} {RecordFailure ()}
	}
\end{algorithm}

\begin{algorithm}[H]
	\caption{boolean \recoverPush\ $()$}
	
	\opInfo\ $*data := Announce[pid]$ \;
	\uIf {$data.done = \True$} {\KwRet \True}
	Node $*iter := Top$ \;
	\While{$iter \neq \NULL$}{
		\uIf {$iter = data.curr$} {
			$data.done := \True$ \;
			\KwRet \True \;
		}
		$iter = iter.next$ \;	
	}
	\uIf {$data.curr.popby \neq \init$} {
			$data.done := \True$ \;
			\KwRet \True \;
	}
	\KwRet \fail \;
\end{algorithm}

\caption{\push\ routine}
\end{figure*}




%%%%%%%%%%%%%%%%%%POP%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}

\begin{algorithm}[H]
	\caption{T \trypop $()$}
	
	Node $*oldTop := Top$ \;
	Node $*newTop$ \;
	$Announce[pid].curr := oldTop$ \;
	\uIf{$oldTop = \NULL$}{\KwRet \emptyst}
	$newTop := oldTop.next$\;
	\uIf{$Top.\CAS(oldTop, newTop)$}{\KwRet $oldTop$}
	\uElse {\KwRet \init}
\end{algorithm}

\begin{algorithm}[H]
	\caption{T \pop\ $()$}
	
	Node $*result$ \;
	\opInfo\ $data$ := new \opInfo\ (\pop, \init, \False) \;
	
	\While{\True}{
		$Announce[pid] := data$ \;
		$result$ := \trypop $()$ \;
		\uIf {$result = \emptyst$} {\KwRet \emptyst}
		\uElseIf {$result \neq \init$} {
			\uIf {$result.popby.\CAS(\init, pid)$} {\KwRet $result.value$}
		}
		$range$ := CalculateRange()\;
		$duration$ := CalculateDuration()\;
		$othervalue$ := \visit $(\NULL, range, duration)$ \;
		\uIf{$othervalue = \timeout$}{RecordFailure ()}
		\uElseIf {$othervalue \neq \NULL$} {
			RecordSuccess ()\;
			\KwRet $othervalue$
		}
	}
	
\end{algorithm}

\begin{algorithm}[H]
	\caption{T \recoverPop $()$}
	
	Node $*nd := Announce[pid].curr$ \;
	\uIf {$nd = \emptyst$} {\KwRet \emptyst}
	\uIf {$nd = \init$} {\KwRet \fail}
	\uIf {$nd.popby \neq \init$} {
		\uIf {$nd.popby = pid$} {\KwRet $nd.value$}
		\uElse {\KwRet \fail}
	}
	\uIf {nd.popby.\CAS(\NULL, id)} {\KwRet result.value}
	\uElse {\KwRet \fail}
\end{algorithm}

\caption{\pop\ routine}
\end{figure*}


 