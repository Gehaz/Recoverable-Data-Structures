\section{Linked-List}

Harris Linked-List uses an Atomic-Markable-Reference object, in which the next field of a Node, in addition to a reference to the next node in the list, is also marked or unmarked. The two fields can be update atomically, either together or individually. This can be done by using the most-significant-bit of next for the marking. For simplicity, we assume reading next returns the reference only, while get\_data() function is used to get (atomically) both the reference and mark bit. Moreover, whenever performing CAS on node.next, both reference and mark state should be mention.
For ease of presentation, we assume a List is initialized with head and tail, containing keys $-\infty, \infty$ respectively. We allow no insert or delete of these keys.

%(a read assigned to either a single or two variables)

The Lookup procedure is used by Insert and Delete in order to find the node with the lowest key greater or equal to the input key, and its predecessor on the list, while physically removing any marked node on its way. To insert a key $\alpha$, a process first finds the right location for $\alpha$ using the Lookup procedure, and then tries to set pred.next to point to a new node containing $\alpha$ by performing CAS. To delete a key $\alpha$, a process looks for it using the Lookup procedure, and then tries to logically remove it by marking curr.next using CAS. In case the marking was successful, the process also tries to physically remove the node. To find a key $\alpha$, a process simply looks for a node in the list with key $\alpha$ which is unmarked.

The linearization point are as follows:
\begin{itemize}
	\item [Insert:] At the point of a successful CAS
	\item [Delete:] At the point of a successful CAS for marking the node (logical delete)
	\item [Find:] At the point where the procedure return, that is, at the read of either curr.key or curr.next.
\end{itemize}

Following the given linearization points (omitting proof...), insert and delete operation are linearized at the point where they affect the system. That is, if an insert operation performed a successful CAS, then all process will see the new node starting from this point, and if a node was logically removed, then all processes treat it as a removed node. Therefore, once a process $p$ recovers following a crash, the List data structure is consistent - if $p$ has a pending operation, either the operation already had a linearization point which affected all other processes, or it did not affect the data structure at all, nor will in any future run.

However, even though the List data structure is consistent, the response of the pending operation is lost. Consider for example a scenario in which process $p$ performs $Delete(\alpha)$ and crash right after applying a successful CAS to mark a node. Upon recovery, $p$ may be able to decide $\alpha$ was removed, as the node is marked. Nevertheless, even if no other process takes steps, $p$ is not able to determine whether it is the process to successfully delete $\alpha$, or that it was done by some other process, and therefore it does not able to determine the right response. Moreover, in case the node was physically removed, $p$ is not able to determine whether $\alpha$ has been deleted at all, as it is no longer part of the list.


\subsubsection{Linked-List Recoverable Version}

To solve the problems mention above, we present a modification for the algorithm such that in case a process fails, upon recovery it is able to complete its last pending operation and also return the response value. The algorithm presented in figure [......]. Blue lines represents changes comparing to the original algorithm (lines that has been added, except for one that was change. See the notes).

Each node is equipped with a new field named deleter. This field is used to determine which process is the one to delete the node. After a process $p$ successfully mark a node (logical delete), it tries to write its id to deleter using CAS. This way, if a process fails during a delete, it can use deleter in order to determine the response value. We assume deleter is initialized to null when creating a new node.

Each process $p$ has a designated location in the memory, Backup[p]. Before trying to apply an operation, $p$ writes to Backup[p] the entire data needed to complete the operation. Upon recovery, $p$ can read Backup[p], and based on it to complete its pending operation, in case there is such. Formally, Backup[p] contains a pointer to a structure containing all the relevant data.
For simplicity, a process creates a new operation structure each time it writes to Backup, although, if used in an alternating manner, two such structures are enough.  


\begin{procedure}[b]
	\footnotesize
	
	\caption{$<$ Node, Node$>$ Lookup $ $ (T key)}
	
	$ \begin{array}{rl}
	\mbox{\textbf{Data: }}	&	\mbox{Node *pred, *curr, *succ} \\
							&	\mbox{boolean mbit}
	\end{array} $
	
%	\textbf{Data: } Node *pred, *curr, *succ
	
	retry: \While{\True}{ \label{find-outer-loop}
		pred := head\;
		curr := head.next\;	
		\While{\True}{
			$\langle$succ, mbit$\rangle$ := curr.next.get\_data() \;
			\uIf(\tcp*[f]{is succ was logically deleted?}) {mbit} {
				\uIf{pred.next.\CAS(unmarked curr,unmarked succ) = \False}{
					\textbf{go to} retry \tcp*{help failed}
				}
				curr := succ \tcp*{help succeed}
			} \uElse {
				\uIf {curr.key $\geq$ key} {
					\KwRet $\langle$pred,curr$\rangle$
				}
				pred := curr\;
				curr := succ\;
			}
		}
	}
	
\end{procedure}

\begin{figure}[h]
	\vspace{-10mm}
	
	\footnotesize
	
	\textbf{Shared variables:} Node *head \\
	
	Type Info \{ \nllabel{StructDefStart} \\
		\hspace*{6mm} \{Insert, Delete\} optype \\
		\hspace*{6mm} Node *nd \\
		\hspace*{6mm} boolean result \\
	\} \\
	
	Code for process p:
	
	\begin{procedure}[H]
		\caption{boolean Insert $ $ (T key)}
		
		$ \begin{array}{rl}
			\mbox{\textbf{Data: }}	&	\mbox{Node *pred, *curr} \\
							&	\mbox{Node new := \textbf{new} Node (key)}
		\end{array} $
		
%		\begin{tabbing}
%			\textbf{Data: } \= Node *pred, *curr \\
%							\> Node new := \textbf{new} Node (key)
%		\end{tabbing}
%		\vspace*{-5mm}
		\textcolor{blue} {Backup[p] := new Info (Insert, new, null)} \;
		\While{\True}{ \label{recover-insert}
			$\langle$pred, curr$\rangle$ := lookup(key)\;
			\uIf{curr.key = key}{
				\textcolor{blue} {Backup[p].result := \False} \;
				\KwRet \False \tcp* {key is already in the list}
			} \uElse {
				node.next := unmarked curr\;
				\uIf{pred.next.\CAS (unmarked curr, unmarked new) \label{insert-CAS}}{
				%	Backup[p].type = InsertDone\;
					\textcolor{blue} {Backup[p].result := \True} \;
					\KwRet \True \tcp*{new node has been inserted}
				}
			}		
		}
		
	\end{procedure}
	
	
	\begin{procedure}[H]
		\caption{boolean Delete $ $ (T key)}
		
		\textbf{Data: } Node *pred, *curr, *succ
		
		\textcolor{blue} {Backup[p] := new Info (Delete, null, null)} \;
		\While{\True}{ \label{recover-delete}
			$\langle$pred, curr$\rangle$ := lookup(key)\;
			\uIf{curr.key $\neq$ key \label{insert-key-in-list}} {
				\textcolor{blue} {Backup[p].result := \False} \;
				\KwRet \False \tcp*{key is not in the list}
			} 
			\uElse {
				\textcolor{blue}{Backup[p].nd := curr}\;
				\While (\tcp*[f]{repeatedly attempt logical delete}) {curr.next is unmarked}{
					succ := curr.next \;
					curr.next.\CAS (unmarked succ, marked succ) \;
				}
				pred.next.\CAS (unmarked curr, unmarked succ) \tcp*{physical delete}
				\textcolor{blue}{curr.deleter.\CAS (null, p)} \tcp*{announce yourself as deleter} \label{recoverable-logical-delete}
				\textcolor{blue}{Backup[p].result := (curr.deleter = p)} \;
				\textcolor{blue}{\KwRet (curr.deleter = p)}
				}
			}	
		
		
		
	\remove{
		\uElse {
				\textcolor{blue}{Backup[p].nd := curr}\;
				succ := curr.next\;
				\uIf(\tcp*[f]{logical delete}) {curr.next.\CAS (unmarked succ, marked succ)} { 
					\textcolor{blue}{curr.deleter.\CAS (null, p)} \tcp*{announce yourself as deleter} \label{recoverable-logical-delete}
					pred.next.\CAS (unmarked curr, unmarked succ) \tcp*{physical delete}
					\textcolor{blue}{Backup[p].result := (curr.deleter = p)} \;
					\textcolor{blue}{\KwRet (curr.deleter = p)} \tcp*{originally return true}
				}
			}	
		}
		
	\end{procedure}

	\begin{procedure}[H]
		\caption{boolean Find $ $ (T key)}
		
		\textbf{Data: } Node *curr := head
		%\KwData{Node* curr = head}	
		
		\While{curr.key $<$ key}{
			curr = curr.next\;	
		}
		\KwRet (curr.key = key $\&\&$ curr.next is unmarked)\;
		
	\end{procedure}

	
	\caption{Recoverable Non-Blocking Linked-List}
	\label{linked-list}
\end{figure}



\begin{procedure}[H]
	\footnotesize
	
	\caption{Recover $ $ (void)}
	
	\uIf {Backup[p].result $\neq$ null} {\KwRet Backup[p].result}
	\uIf{Backup[p].optype = Insert}{
		\uIf{Backup[p].nd is in the list $||$ Backup[p].nd.next is marked}{
			\KwRet \True\;
		} \uElse {
			\KwRet FAIL
			%\textbf{go to} \ref{recover-insert} \tcp*{restart Insert}
		}	
	}
	\uIf{Backup[p].optype = Delete}{
		\uIf{Backup[p].nd $\neq$ null \&\& Backup[p].nd.next is marked}{
			\textbf{go to} \ref{recoverable-logical-delete} with curr := nd\tcp*{try to complete the deletation}
		} \uElse {
			\KwRet FAIL
			%\textbf{go to} \ref{recover-delete} \tcp*{restart Delete}
		}
	}
	
\end{procedure}


\newpage
\subsubsection*{Correctness Argument}
In the following, we give an high-level proof for the correctness of the algorithm.

First, notice that quitting the Lookup procedure at any point, or repeating it, can not violet the list consistency. The Lookup procedure simply traverse the list, while trying to physically delete marked nodes.
Once curr.next is marked, a single process can perform the physical delete. This follows from the fact that at any point there is a single node in the list which points to curr. Once curr is physically delete, no node in the list points to curr, and thus any CAS operation with curr as the first parameter will fail. This observation relays on the fact that any new allocated node has a different address then curr.
As a result, repeating the attempt to physically delete a node does not affect the list.

A key argument in the proof is that if an insert operation is yet to perform a successful CAS (in line \ref{insert-CAS}), then considering the operation as not having a linearization point does not violate the list consistency. This follows from the fact the operation did not affected any process. In particular, repeating the operation in such case is also safe. As a result, if a process performing insert is about to return false, due to the fact key is already in the tree, and crash, then considering the operation as FAIL upon recovery does not violate consistency.
A similar argument holds for delete operation and CAS for logic delete.

fails because key is already in the list, then aborting it (i.e., considering it as not having a linearization point) does not violate the consistency of list. This follows from the fact that such an operation does not affect any other process. Moreover, even repeating the operation in such case (assuming it did not return yet) can not violate consistency, from the same reason. A similar argument holds for delete operation which fails because key is not in the list.

Assume a process $p$ performs $insert(key)$ operation. Then, $p$ creates a new node ndnew with 

For the Insert operation, $p$ tries to add the new node by performing a CAS. If it succeeds it will return true if it suffers no failure. In case of a failure after writing to Backup[p], upon recovery $p$ tries to complete its operation. If it already performed a successful CAS, that is, the node was added to the list, then either it is still in the list or that it was deleted. Therefore, if $p$ can find the new node in the list (using a procedure similar to find), or that it is marked, it must be that the node was added, and $p$ can return true. Otherwise, $p$ either crashed before performing the CAS, or that the CAS was unsuccessful. In both cases, the new node was not added, and $p$ can restart the Insert procedure.

For the delete operation, once $p$ logically delete a node $v$, it also tries to announce itself as the "removal" of the node by writing its id to deleter using CAS. Assume a process $p$ crash while trying to delete the node. Upon recovery, if $p$ sees the node is not marked, then obliviously its deletion did not took affect, and it can restart the delete operation. However, if the node is marked, it might be that $p$ marked it before the crash, or it might be some other process trying to delete the same node did so. As $p$ can not distinguish between the two, and since we desire for a lock-free implementation, we let $p$ to try and complete the deletion, even if it is not to process to logically delete the node. To avoid a scenario in which more then a single process "delete" the same node, they all compete for deleter using CAS. The first one to perform it will win, and it is the only process to return true. It is easy to verify once a process writes to deleter, then eventually, if given enough time with no crash, it returns true, while any other process trying to delete the same node will have to retry the delete operation.

 