\section{Linked-List}

\DontPrintSemicolon
\SetKw{CAS}{CAS}
\SetKw{True}{true}
\SetKw{False}{false}
\SetKw{Int}{int}

The original algorithm by Harris is presented in Figure \ref{Harris original}. Harris approach uses an Atomic-Markable-Reference object, in which the next field of a Node, in addition to a reference to the next node in the list, is also marked or unmarked. The two fields can be update atomically, either together or individually. This can be done by using the most-significant-bit of next for the marking. For simplicity, we assume node.next returns the reference, while a query can be used to identify if it is marked. Therefore, whenever writing to node.next, or performing CAS, both the reference and marking state should be mention.
For ease of presentation, we assume a List is initialised with head and tail, containing keys $-\infty, \infty$ respectively. We allow no insert or delete of these keys.

The Lookup procedure is used by Insert and Delete in order to find the node with the lowest key greater or equal to the input key, and its predecessor on the list, while physically removing any marked node on its way. To insert a key $\alpha$, a process first finds the right location for $\alpha$ using the Lookup procedure, and then tries to set pred.next to point to a new node containing $\alpha$ by performing CAS. To delete a key $\alpha$, a process looks for it using the Lookup procedure, and then tries to logically remove it by marking curr.next using CAS. In case the marking was successful, the process also tries to physically remove the node. To find a key $\alpha$, a process simply looks for a node in the list with key $\alpha$ which is unmarked.



\begin{procedure}[H]
	\caption{Lookup (int key)}
	
	\KwData{Node* pred, curr, succ}
		
	retry: \While{\True}{ \label{find-outer-loop}
		pred = head\;
		curr = head.next\;	
		\While{\True}{
			succ = curr.next\;
			\eIf{curr.next is marked}{
				\If{pred.next.\CAS(unmarked curr,unmarked succ) == \False}{
					\textbf{go to} retry\;
				}
				curr = succ\;
			}{
				\If {curr.key $\geq$ key} {
					\KwRet $<$pred,curr$>$
				}
				pred = curr\;
				curr = succ\;
			}
		}
	}
		
\end{procedure}



\begin{figure}
	
	\textbf{Shared variables:} Node* head

	\begin{procedure}[H]
		\caption{Insert (int key)}
		
		\KwData{Node* pred, curr\;
		$\qquad \quad$ Node node = \textbf{new} Node (key)\;
	}	
		
		\While{\True}{
			$<$pred, curr$>$ = lookup(key)\;
			\eIf{curr.key == key}{
				\KwRet \False\;
			}{
				node.next = unmarked curr\;
				\If{pred.next.\CAS (unmarked curr, unmarked node)}{
				\KwRet \True\;
				}
			}		
		}
		
	\end{procedure}


	\begin{procedure}[H]
		\caption{Delete (int key)}
		
		\KwData{Node* pred, curr, succ}	
		
		\While{\True}{
			$<$pred, curr$>$ = lookup(key)\;
			\eIf{curr.key != key}{
				\KwRet \False\;
			}{
				succ = curr.next\;
				\If{curr.next.\CAS (unmarked succ, marked succ)}{ \label{harris-logical-delete}
					pred.next.\CAS (unmarked curr, unmarked succ)\;
					\KwRet \True\;
				}
			}	
		}
		
	\end{procedure}
	
	\begin{procedure}[H]
		\caption{Find (int key)}
		
		\KwData{Node* curr = head}	
		
		\While{curr.key $<$ key}{
			curr = curr.next\;	
		}
		\KwRet (curr.key == key $\&\&$ curr.next is unmarked)\;
		
	\end{procedure}
	
	\caption{Harris Non-Blocking Algorithm}
	\label{Harris original}
\end{figure}

\newpage
\subsubsection{Crash-Recovery}

The linearization point are as follows:
\begin{itemize}
	\item [Insert:] At the point of a successful CAS
	\item [Delete:] At the point of a successful CAS for marking the node (logical delete)
	\item [Find:] At the point of the procedure return, that is, either when curr.key != key, or at the second condition test.
\end{itemize}

Following these linearization points (committing proof...), insert and delete operation are linearized at the point where they affect the system. That is, if there is a linearization point for insert operation, then all process will see the new node starting from this point, and if a node was logically removed, then all processes treat it as a removed node. Therefore, once a process $p$ recovers following a crash, the List data structure is consistent - if $p$ has a pending operation, either the operation already had a linearization point and affect all other processes, or it did not affect the data structure at all.

However, even though the List data structure is consistent, the response of the pending operation is lost. Consider for example a scenario in which process $p$ performs $Delete(\alpha)$ and crash at line \ref{harris-logical-delete} after performing a successful CAS. Upon recovery, $p$ may be able to decide $\alpha$ was removed, as the node is marked. Nevertheless, even if no other process takes steps, $p$ is not able to determine whether it is the process to successfully delete $\alpha$, or that it was done by some other process, and therefore it does not able to determine the right response. Moreover, in case the node was physically removed, $p$ is not able to determine whether $\alpha$ has been deleted, as it is no longer part of the list.


\subsubsection{Harris Recoverable Version}

To solve the problems mention above, we present a mechanise such that in case a process fails, upon recovery it is able to determine whether its last operation already took affect, and in such case to complete it and also return the right response. In case the operation did not took affect nor it will in any future run, $p$ is allowed to ignore the operation.

Each node is equipped with a new field named owner. This field is used to determine which process is the one to delete the node. After a process $p$ successfully mark a node (logical delete), it tries to write its id to owner using CAS. This way



Each node is equipped with a new field, owner, which keeps the identity of the deleting process. When deleting a node, process $p$ first tries to set owner to $p$ using CAS, and only then tries to mark the node. Since the deletion process is split, an helping mechanism is needed. If a process does not win the race for owner, it still tries to mark the node, helping the owner to complete its operation.

Process $p$ has a designated location in the memory, Announce[p]. Before trying to apply an operation, $p$ writes to Announce[p] the entire data needed to complete the operation. Upon recovery, $p$ can read Announce[p], and based on it to complete its pending operation, in case there is such. Formally, Announce[p] contains a pointer to a structure containing all the relevant data.


\begin{figure}
	
	\textbf{Shared variables:} Node* head \\
	
	Define operation: struct \{ \nllabel{StructDefStart}
	\emph{type}: OperationType, \emph{pred},\emph{curr}, \emph{new}: Node*, \emph{done}: bool \}
	
	\begin{procedure}[H]
		\caption{Insert (int key)}
		
		\KwData{Node* pred, curr\;
			$\qquad \quad$ Node node = \textbf{new} Node (key)\;
		}
		
		\While{\True}{
			$<$pred, curr$>$ = lookup(key)\;
			\eIf{curr.key == key}{
				\KwRet \False\;
			}{
				node.next = unmarked curr\;
				Announce[p] = new operation (Insert, pred, curr, new, \False)\;
				\If{pred.next.\CAS (unmarked curr, unmarked node)}{
					Announce[p].done = \True\;
					\KwRet \True\;
				}
			}		
		}
		
	\end{procedure}
	
	
	\begin{procedure}[H]
		\caption{Delete (int key)}
		
		\KwData{Node* pred, curr, succ}	
		
		\While{\True}{
			$<$pred, curr$>$ = lookup(key)\;
			\eIf{curr.key != key}{
				\KwRet \False\;
			}{
				succ = curr.next\;
				Announe[p] = new operation (Delete, pred, curr, null, \False)\;
				\If{curr.next.\CAS (unmarked succ, marked succ)}{ \label{harris-logical-delete}
					pred.next.\CAS (unmarked curr, unmarked succ)\;
					\KwRet \True\;
				}
			}	
		}
		
	\end{procedure}
	
	\begin{procedure}[H]
		\caption{Find (int key)}
		
		\KwData{Node* curr = head}	
		
		\While{curr.key $<$ key}{
			curr = curr.next\;	
		}
		\KwRet (curr.key == key $\&\&$ curr.next is unmarked)\;
		
	\end{procedure}
	
	\caption{Harris Non-Blocking Algorithm}
	\label{Harris original}
\end{figure}