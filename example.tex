\section{Linked-List}

\DontPrintSemicolon
\SetKw{CAS}{CAS}
\SetKw{True}{true}
\SetKw{False}{false}
\SetKw{Int}{int}

The original algorithm by Harris is presented in Figure \ref{Harris original}. Harris approach uses an Atomic-Markable-Reference object, in which the next field of a Node, in addition to a reference to the next node in the list, is also marked or unmarked. The two fields can be update atomically, either together or individually. This can be done by using the most-significant-bit of next for the marking. For simplicity, we assume node.next returns the reference, while a query can be used to identify if it is marked. Therefore, whenever writing to node.next, or performing CAS, both the reference and marking state should be mention.
For ease of presentation, we assume a List is initialised with head and tail, containing keys $-\infty, \infty$ respectively. We allow no insert or delete of these keys.

The Lookup procedure is used by Insert and Delete in order to find the node with the lowest key greater or equal to the input key, and its predecessor on the list, while physically removing any marked node on its way. To insert a key $\alpha$, a process first finds the right location for $\alpha$ using the Lookup procedure, and then tries to set pred.next to point to a new node containing $\alpha$ by performing CAS. To delete a key $\alpha$, a process looks for it using the Lookup procedure, and then tries to logically remove it by marking curr.next using CAS. In case the marking was successful, the process also tries to physically remove the node. To find a key $\alpha$, a process simply looks for a node in the list with key $\alpha$ which is unmarked.



\begin{procedure}[H]
	\caption{Lookup (int key)}
	
	\KwData{Node* pred, curr, succ}
		
	retry: \While{\True}{ \label{find-outer-loop}
		pred = head\;
		curr = head.next\;	
		\While{\True}{
			succ = curr.next\;
			\eIf{curr.next is marked}{
				\If{pred.next.\CAS(unmarked curr,unmarked succ) == \False}{
					\textbf{go to} retry\;
				}
				curr = succ\;
			}{
				\If {curr.key $\geq$ key} {
					\KwRet $<$pred,curr$>$
				}
				pred = curr\;
				curr = succ\;
			}
		}
	}
		
\end{procedure}



\begin{figure}
	
	\textbf{Shared variables:} Node* head

	\begin{procedure}[H]
		\caption{Insert (int key)}
		
		\KwData{Node* pred, curr\;
		$\qquad \quad$ Node node = \textbf{new} Node (key)\;
	}	
		
		\While{\True}{
			$<$pred, curr$>$ = lookup(key)\;
			\eIf{curr.key == key}{
				\KwRet \False\;
			}{
				node.next = unmarked curr\;
				\If{pred.next.\CAS (unmarked curr, unmarked node)}{
				\KwRet \True\;
				}
			}		
		}
		
	\end{procedure}


	\begin{procedure}[H]
		\caption{Delete (int key)}
		
		\KwData{Node* pred, curr, succ}	
		
		\While{\True}{
			$<$pred, curr$>$ = lookup(key)\;
			\eIf{curr.key != key}{
				\KwRet \False\;
			}{
				succ = curr.next\;
				\If{curr.next.\CAS (unmarked succ, marked succ)}{ \label{harris-logical-delete}
					pred.next.\CAS (unmarked curr, unmarked succ)\;
					\KwRet \True\;
				}
			}	
		}
		
	\end{procedure}
	
	\begin{procedure}[H]
		\caption{Find (int key)}
		
		\KwData{Node* curr = head}	
		
		\While{curr.key $<$ key}{
			curr = curr.next\;	
		}
		\KwRet (curr.key == key $\&\&$ curr.next is unmarked)\;
		
	\end{procedure}
	
	\caption{Harris Non-Blocking Algorithm}
	\label{Harris original}
\end{figure}

\newpage
\subsubsection{Crash-Recovery}

The linearization point are as follows:
\begin{itemize}
	\item [Insert:] At the point of a successful CAS
	\item [Delete:] At the point of a successful CAS for marking the node (logical delete)
	\item [Find:] At the point of the procedure return, that is, either when curr.key != key, or at the second condition test.
\end{itemize}

Following these linearization points (committing proof...), insert and delete operation are linearized at the point where they affect the system. That is, if there is a linearization point for insert operation, then all process will see the new node starting from this point, and if a node was logically removed, then all processes treat it as a removed node. Therefore, once a process $p$ recovers following a crash, the List data structure is consistent - if $p$ has a pending operation, either the operation already had a linearization point and affect all other processes, or it did not affect the data structure at all.

However, even though the List data structure is consistent, the response of the pending operation is lost. Consider for example a scenario in which process $p$ performs $Delete(\alpha)$ and crash at line \ref{harris-logical-delete} after performing a successful CAS. Upon recovery, $p$ may be able to decide $\alpha$ was removed, as the node is marked. Nevertheless, even if no other process takes steps, $p$ is not able to determine whether it is the process to successfully delete $\alpha$, or that it was done by some other process, and therefore it does not able to determine the right response. Moreover, in case the node was physically removed, $p$ is not able to determine whether $\alpha$ has been deleted, as it is no longer part of the list.


\subsubsection{Linked-List Recoverable Version}

To solve the problems mention above, we present a modification for the algorithm such that in case a process fails, upon recovery it is able to complete its last pending operation and also return the response value.

Each node is equipped with a new field named deleter. This field is used to determine which process is the one to delete the node. After a process $p$ successfully mark a node (logical delete), it tries to write its id to deleter using CAS. This way, if a process fails during a delete, it can use deleter in order to determine the response value. We assume deleter is initialized to null when creating a new node.

Each process $p$ has a designated location in the memory, Backup[p]. Before trying to apply an operation, $p$ writes to Backup[p] the entire data needed to complete the operation. Upon recovery, $p$ can read Backup[p], and based on it to complete its pending operation, in case there is such. Formally, Backup[p] contains a pointer to a structure containing all the relevant data.

We present the modified algorithm. Only the procedures which require changes are presented. For simplicity, a process creates a new operation structure each time it writes to Backup, although a process can use two such structures alternately.


\begin{figure}
	
	\textbf{Shared variables:} Node* head \\
	
	Define Info: struct \{ \nllabel{StructDefStart}
	\emph{type}: OperationType, \emph{pred},\emph{curr}, \emph{new}: Node* \} \\
	
	Code for process p:\\
	\begin{procedure}[H]
		\caption{Insert (int key)}
		
		\KwData{Node* pred, curr\;
			$\qquad \quad$ Node node = \textbf{new} Node (key)\;
		}
		
		\While{\True}{ \label{recover-insert}
			$<$pred, curr$>$ = lookup(key)\;
			\eIf{curr.key == key}{
				\KwRet \False\;
			}{
				node.next = unmarked curr\;
				Backup[p] = new Info (Insert, pred, curr, new)\;
				\If{pred.next.\CAS (unmarked curr, unmarked node)}{
				%	Backup[p].type = InsertDone\;
					\KwRet \True\;
				}
			}		
		}
		
	\end{procedure}
	
	
	\begin{procedure}[H]
		\caption{Delete (int key)}
		
		\KwData{Node* pred, curr, succ}	
		
		\While{\True}{ \label{recover-delete}
			$<$pred, curr$>$ = lookup(key)\;
			\eIf{curr.key != key}{
				\KwRet \False\;
			}{
				succ = curr.next\;
				Announe[p] = new Info (Delete, pred, curr, null)\;
				\If{curr.next.\CAS (unmarked succ, marked succ)}{ 
					curr.deleter.\CAS (null, p)\; \label{recoverable-logical-delete}
					pred.next.\CAS (unmarked curr, unmarked succ)\;
					\KwRet (curr.deleter == p)\;
				}
			}	
		}
		
	\end{procedure}

	
	\caption{Recoverable Non-Blocking Linked-List}
	\label{recoverable algorithm}
\end{figure}



\newpage

\begin{procedure}[H]
	\caption{Recover ()}
	
	\If{Backup[p].type = Insert}{
		\eIf{Backup[p].new is in the list $||$ Backup[p].curr.next is marked}{
			\KwRet \True\;
		}{
			\textbf{go to} \ref{recover-insert} \tcp*{restart Insert}\;
		}	
	}
	\If{Backup[p].type == Delete}{
		\eIf{Backup[p].curr.next is marked}{
			\textbf{go to} \ref{recoverable-logical-delete} \tcp*{try to complete the deletation}\;
		}{
			\textbf{go to} \ref{recover-delete} \tcp*{restart Delete}\;
		}
	}
	
\end{procedure}

\subsubsection*{Correctness Argument}
In the following, we give an intuition for the correctness of the algorithm.

For the Insert operation, $p$ tries to add the new node by performing a CAS. If it succeeds it will return true if it suffers no failure. In case of a failure after writing to Backup[p], upon recovery $p$ tries to complete its operation. If it already performed a successful CAS, that is, the node was added to the list, then either it is still in the list or that it was deleted. Therefore, if $p$ can find the new node in the list (using a procedure similar to find), or that it is marked, it must be that the node was added, and $p$ can return true. Otherwise, $p$ either crashed before performing the CAS, or that the CAS was unsuccessful. In both cases, the new node was not added, and $p$ can restart the Insert procedure.

For the delete operation, once $p$ logically delete a node $v$, it also tries to announce itself as the "removal" of the node by writing its id to deleter using CAS. Assume a process $p$ crash while trying to delete the node. Upon recovery, if $p$ sees the node is not marked, then obliviously its deletion did not took affect, and it can restart the delete operation. However, if the node is marked, it might be that $p$ marked it before the crash, or it might be some other process trying to delete the same node did so. As $p$ can not distinguish between the two, and since we desire for a lock-free implementation, we let $p$ to try and complete the deletion, even if it is not to process to logically delete the node. To avoid a scenario in which more then a single process "delete" the same node, they all compete for deleter using CAS. The first one to perform it will win, and it is the only process to return true. It is easy to verify once a process writes to deleter, then eventually, if given enough time with no crash, it returns true, while any other process trying to delete the same node will have to retry the delete operation.








 